/*
 * generated by Xtext 2.16.0
 */
package org.xtext.example.sml.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class SmlGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cArenasAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cArenasArenaParserRuleCall_0_0 = (RuleCall)cArenasAssignment_0.eContents().get(0);
		private final Assignment cEnvAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEnvEnvironmentParserRuleCall_1_0 = (RuleCall)cEnvAssignment_1.eContents().get(0);
		private final Assignment cSwAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSwSwarmconfParserRuleCall_2_0 = (RuleCall)cSwAssignment_2.eContents().get(0);
		private final Assignment cObAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cObMissionObjectiveParserRuleCall_3_0 = (RuleCall)cObAssignment_3.eContents().get(0);
		
		//Model:
		//	arenas=Arena env=Environment sw=Swarmconf ob=MissionObjective;
		@Override public ParserRule getRule() { return rule; }
		
		//arenas=Arena env=Environment sw=Swarmconf ob=MissionObjective
		public Group getGroup() { return cGroup; }
		
		//arenas=Arena
		public Assignment getArenasAssignment_0() { return cArenasAssignment_0; }
		
		//Arena
		public RuleCall getArenasArenaParserRuleCall_0_0() { return cArenasArenaParserRuleCall_0_0; }
		
		//env=Environment
		public Assignment getEnvAssignment_1() { return cEnvAssignment_1; }
		
		//Environment
		public RuleCall getEnvEnvironmentParserRuleCall_1_0() { return cEnvEnvironmentParserRuleCall_1_0; }
		
		//sw=Swarmconf
		public Assignment getSwAssignment_2() { return cSwAssignment_2; }
		
		//Swarmconf
		public RuleCall getSwSwarmconfParserRuleCall_2_0() { return cSwSwarmconfParserRuleCall_2_0; }
		
		//ob=MissionObjective
		public Assignment getObAssignment_3() { return cObAssignment_3; }
		
		//MissionObjective
		public RuleCall getObMissionObjectiveParserRuleCall_3_0() { return cObMissionObjectiveParserRuleCall_3_0; }
	}
	public class EnvironmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Environment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cTheKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cArenaKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cContainsKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Keyword cTheKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Keyword cFollowingKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Keyword cElementsKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Keyword cColonKeyword_0_6 = (Keyword)cGroup_0.eContents().get(6);
		private final Assignment cEnvironmentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEnvironmentEnvironmentElementsParserRuleCall_1_0 = (RuleCall)cEnvironmentAssignment_1.eContents().get(0);
		
		//Environment:
		//	('The' 'arena' 'contains' 'the' 'following' 'elements' ':')? environment+=EnvironmentElements*;
		@Override public ParserRule getRule() { return rule; }
		
		//('The' 'arena' 'contains' 'the' 'following' 'elements' ':')? environment+=EnvironmentElements*
		public Group getGroup() { return cGroup; }
		
		//('The' 'arena' 'contains' 'the' 'following' 'elements' ':')?
		public Group getGroup_0() { return cGroup_0; }
		
		//'The'
		public Keyword getTheKeyword_0_0() { return cTheKeyword_0_0; }
		
		//'arena'
		public Keyword getArenaKeyword_0_1() { return cArenaKeyword_0_1; }
		
		//'contains'
		public Keyword getContainsKeyword_0_2() { return cContainsKeyword_0_2; }
		
		//'the'
		public Keyword getTheKeyword_0_3() { return cTheKeyword_0_3; }
		
		//'following'
		public Keyword getFollowingKeyword_0_4() { return cFollowingKeyword_0_4; }
		
		//'elements'
		public Keyword getElementsKeyword_0_5() { return cElementsKeyword_0_5; }
		
		//':'
		public Keyword getColonKeyword_0_6() { return cColonKeyword_0_6; }
		
		//environment+=EnvironmentElements*
		public Assignment getEnvironmentAssignment_1() { return cEnvironmentAssignment_1; }
		
		//EnvironmentElements
		public RuleCall getEnvironmentEnvironmentElementsParserRuleCall_1_0() { return cEnvironmentEnvironmentElementsParserRuleCall_1_0; }
	}
	public class ProbabilisticDecriptionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.ProbabilisticDecription");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDistributedKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cWithKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cDisAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDisDistributionParserRuleCall_3_0 = (RuleCall)cDisAssignment_3.eContents().get(0);
		private final Keyword cDistributionKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cInKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cAKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cKAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cKRegionParserRuleCall_7_0 = (RuleCall)cKAssignment_7.eContents().get(0);
		
		//ProbabilisticDecription:
		//	'distributed' 'with' 'a' dis=Distribution 'distribution' 'in' 'a' k=Region;
		@Override public ParserRule getRule() { return rule; }
		
		//'distributed' 'with' 'a' dis=Distribution 'distribution' 'in' 'a' k=Region
		public Group getGroup() { return cGroup; }
		
		//'distributed'
		public Keyword getDistributedKeyword_0() { return cDistributedKeyword_0; }
		
		//'with'
		public Keyword getWithKeyword_1() { return cWithKeyword_1; }
		
		//'a'
		public Keyword getAKeyword_2() { return cAKeyword_2; }
		
		//dis=Distribution
		public Assignment getDisAssignment_3() { return cDisAssignment_3; }
		
		//Distribution
		public RuleCall getDisDistributionParserRuleCall_3_0() { return cDisDistributionParserRuleCall_3_0; }
		
		//'distribution'
		public Keyword getDistributionKeyword_4() { return cDistributionKeyword_4; }
		
		//'in'
		public Keyword getInKeyword_5() { return cInKeyword_5; }
		
		//'a'
		public Keyword getAKeyword_6() { return cAKeyword_6; }
		
		//k=Region
		public Assignment getKAssignment_7() { return cKAssignment_7; }
		
		//Region
		public RuleCall getKRegionParserRuleCall_7_0() { return cKRegionParserRuleCall_7_0; }
	}
	public class SwarmconfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Swarmconf");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTheKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cRobotKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cSwarmKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cConsistsKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cOfKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cXAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cXRangeParserRuleCall_5_0 = (RuleCall)cXAssignment_5.eContents().get(0);
		private final Assignment cRAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cRRobotParserRuleCall_6_0 = (RuleCall)cRAssignment_6.eContents().get(0);
		private final Assignment cPrAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cPrProbabilisticDecriptionParserRuleCall_7_0 = (RuleCall)cPrAssignment_7.eContents().get(0);
		
		//Swarmconf:
		//	'The' 'robot' 'swarm' 'consists' 'of' x=Range r=Robot pr=ProbabilisticDecription
		//	//('distributed' 'in' dis=Distribution 'way' 'in' k=Region )*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'The' 'robot' 'swarm' 'consists' 'of' x=Range r=Robot pr=ProbabilisticDecription
		public Group getGroup() { return cGroup; }
		
		//'The'
		public Keyword getTheKeyword_0() { return cTheKeyword_0; }
		
		//'robot'
		public Keyword getRobotKeyword_1() { return cRobotKeyword_1; }
		
		//'swarm'
		public Keyword getSwarmKeyword_2() { return cSwarmKeyword_2; }
		
		//'consists'
		public Keyword getConsistsKeyword_3() { return cConsistsKeyword_3; }
		
		//'of'
		public Keyword getOfKeyword_4() { return cOfKeyword_4; }
		
		//x=Range
		public Assignment getXAssignment_5() { return cXAssignment_5; }
		
		//Range
		public RuleCall getXRangeParserRuleCall_5_0() { return cXRangeParserRuleCall_5_0; }
		
		//r=Robot
		public Assignment getRAssignment_6() { return cRAssignment_6; }
		
		//Robot
		public RuleCall getRRobotParserRuleCall_6_0() { return cRRobotParserRuleCall_6_0; }
		
		//pr=ProbabilisticDecription
		public Assignment getPrAssignment_7() { return cPrAssignment_7; }
		
		//ProbabilisticDecription
		public RuleCall getPrProbabilisticDecriptionParserRuleCall_7_0() { return cPrProbabilisticDecriptionParserRuleCall_7_0; }
	}
	public class MissionTimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.MissionTime");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTheKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cTotalKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cTimeKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cOfKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cTheKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cMissionKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cIsKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cTAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cTRangeParserRuleCall_7_0 = (RuleCall)cTAssignment_7.eContents().get(0);
		
		//MissionTime:
		//	'The' 'total' 'time' 'of' 'the' 'mission' 'is' T=Range;
		@Override public ParserRule getRule() { return rule; }
		
		//'The' 'total' 'time' 'of' 'the' 'mission' 'is' T=Range
		public Group getGroup() { return cGroup; }
		
		//'The'
		public Keyword getTheKeyword_0() { return cTheKeyword_0; }
		
		//'total'
		public Keyword getTotalKeyword_1() { return cTotalKeyword_1; }
		
		//'time'
		public Keyword getTimeKeyword_2() { return cTimeKeyword_2; }
		
		//'of'
		public Keyword getOfKeyword_3() { return cOfKeyword_3; }
		
		//'the'
		public Keyword getTheKeyword_4() { return cTheKeyword_4; }
		
		//'mission'
		public Keyword getMissionKeyword_5() { return cMissionKeyword_5; }
		
		//'is'
		public Keyword getIsKeyword_6() { return cIsKeyword_6; }
		
		//T=Range
		public Assignment getTAssignment_7() { return cTAssignment_7; }
		
		//Range
		public RuleCall getTRangeParserRuleCall_7_0() { return cTRangeParserRuleCall_7_0; }
	}
	public class MissionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Mission");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTheKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cMissionKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cOfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cTheKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cRobotsKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cIsKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cToKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cTAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cTTaskParserRuleCall_7_0 = (RuleCall)cTAssignment_7.eContents().get(0);
		private final Assignment cMAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cMMetricParserRuleCall_8_0 = (RuleCall)cMAssignment_8.eContents().get(0);
		
		//Mission:
		//	'The' 'mission' 'of' 'the' 'robots' 'is' 'to' t=Task m=Metric;
		@Override public ParserRule getRule() { return rule; }
		
		//'The' 'mission' 'of' 'the' 'robots' 'is' 'to' t=Task m=Metric
		public Group getGroup() { return cGroup; }
		
		//'The'
		public Keyword getTheKeyword_0() { return cTheKeyword_0; }
		
		//'mission'
		public Keyword getMissionKeyword_1() { return cMissionKeyword_1; }
		
		//'of'
		public Keyword getOfKeyword_2() { return cOfKeyword_2; }
		
		//'the'
		public Keyword getTheKeyword_3() { return cTheKeyword_3; }
		
		//'robots'
		public Keyword getRobotsKeyword_4() { return cRobotsKeyword_4; }
		
		//'is'
		public Keyword getIsKeyword_5() { return cIsKeyword_5; }
		
		//'to'
		public Keyword getToKeyword_6() { return cToKeyword_6; }
		
		//t=Task
		public Assignment getTAssignment_7() { return cTAssignment_7; }
		
		//Task
		public RuleCall getTTaskParserRuleCall_7_0() { return cTTaskParserRuleCall_7_0; }
		
		//m=Metric
		public Assignment getMAssignment_8() { return cMAssignment_8; }
		
		//Metric
		public RuleCall getMMetricParserRuleCall_8_0() { return cMMetricParserRuleCall_8_0; }
	}
	public class TaskElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Task");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAggregateKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cOnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRRegionParserRuleCall_2_0 = (RuleCall)cRAssignment_2.eContents().get(0);
		
		//Task:
		//	'aggregate' 'on' r=Region;
		@Override public ParserRule getRule() { return rule; }
		
		//'aggregate' 'on' r=Region
		public Group getGroup() { return cGroup; }
		
		//'aggregate'
		public Keyword getAggregateKeyword_0() { return cAggregateKeyword_0; }
		
		//'on'
		public Keyword getOnKeyword_1() { return cOnKeyword_1; }
		
		//r=Region
		public Assignment getRAssignment_2() { return cRAssignment_2; }
		
		//Region
		public RuleCall getRRegionParserRuleCall_2_0() { return cRRegionParserRuleCall_2_0; }
	}
	public class MetricElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Metric");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cSecondsKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cStepsKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//Metric:
		//	'seconds' | 'steps';
		@Override public ParserRule getRule() { return rule; }
		
		//'seconds' | 'steps'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'seconds'
		public Keyword getSecondsKeyword_0() { return cSecondsKeyword_0; }
		
		//'steps'
		public Keyword getStepsKeyword_1() { return cStepsKeyword_1; }
	}
	public class MissionObjectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.MissionObjective");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTheKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cPerformanceKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cMeasureKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cIsKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cDefinedKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cInKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cTermsKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cOfKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cAnKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Keyword cObjectiveKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Keyword cFunctionKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Keyword cThatKeyword_11 = (Keyword)cGroup.eContents().get(11);
		private final Keyword cMaximizesKeyword_12 = (Keyword)cGroup.eContents().get(12);
		private final Keyword cTheKeyword_13 = (Keyword)cGroup.eContents().get(13);
		private final Keyword cFollowingKeyword_14 = (Keyword)cGroup.eContents().get(14);
		private final Keyword cScoreKeyword_15 = (Keyword)cGroup.eContents().get(15);
		private final Keyword cColonKeyword_16 = (Keyword)cGroup.eContents().get(16);
		private final Assignment cInAssignment_17 = (Assignment)cGroup.eContents().get(17);
		private final RuleCall cInIndicatorParserRuleCall_17_0 = (RuleCall)cInAssignment_17.eContents().get(0);
		
		//MissionObjective:
		//	'The' 'performance' 'measure' 'is' 'defined' 'in' 'terms' 'of' 'an' 'objective' 'function' 'that' 'maximizes' 'the'
		//	'following' 'score' ':' in+=Indicator*;
		@Override public ParserRule getRule() { return rule; }
		
		//'The' 'performance' 'measure' 'is' 'defined' 'in' 'terms' 'of' 'an' 'objective' 'function' 'that' 'maximizes' 'the'
		//'following' 'score' ':' in+=Indicator*
		public Group getGroup() { return cGroup; }
		
		//'The'
		public Keyword getTheKeyword_0() { return cTheKeyword_0; }
		
		//'performance'
		public Keyword getPerformanceKeyword_1() { return cPerformanceKeyword_1; }
		
		//'measure'
		public Keyword getMeasureKeyword_2() { return cMeasureKeyword_2; }
		
		//'is'
		public Keyword getIsKeyword_3() { return cIsKeyword_3; }
		
		//'defined'
		public Keyword getDefinedKeyword_4() { return cDefinedKeyword_4; }
		
		//'in'
		public Keyword getInKeyword_5() { return cInKeyword_5; }
		
		//'terms'
		public Keyword getTermsKeyword_6() { return cTermsKeyword_6; }
		
		//'of'
		public Keyword getOfKeyword_7() { return cOfKeyword_7; }
		
		//'an'
		public Keyword getAnKeyword_8() { return cAnKeyword_8; }
		
		//'objective'
		public Keyword getObjectiveKeyword_9() { return cObjectiveKeyword_9; }
		
		//'function'
		public Keyword getFunctionKeyword_10() { return cFunctionKeyword_10; }
		
		//'that'
		public Keyword getThatKeyword_11() { return cThatKeyword_11; }
		
		//'maximizes'
		public Keyword getMaximizesKeyword_12() { return cMaximizesKeyword_12; }
		
		//'the'
		public Keyword getTheKeyword_13() { return cTheKeyword_13; }
		
		//'following'
		public Keyword getFollowingKeyword_14() { return cFollowingKeyword_14; }
		
		//'score'
		public Keyword getScoreKeyword_15() { return cScoreKeyword_15; }
		
		//':'
		public Keyword getColonKeyword_16() { return cColonKeyword_16; }
		
		//in+=Indicator*
		public Assignment getInAssignment_17() { return cInAssignment_17; }
		
		//Indicator
		public RuleCall getInIndicatorParserRuleCall_17_0() { return cInIndicatorParserRuleCall_17_0; }
	}
	public class IndicatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Indicator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSpScopeParserRuleCall_0_0 = (RuleCall)cSpAssignment_0.eContents().get(0);
		private final Assignment cOcAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cOcAlternatives_1_0 = (Alternatives)cOcAssignment_1.eContents().get(0);
		private final RuleCall cOcAtomicIndicatorParserRuleCall_1_0_0 = (RuleCall)cOcAlternatives_1_0.eContents().get(0);
		private final RuleCall cOcCompoundIndicatorParserRuleCall_1_0_1 = (RuleCall)cOcAlternatives_1_0.eContents().get(1);
		
		//Indicator:
		//	sp=Scope oc=(AtomicIndicator | CompoundIndicator);
		@Override public ParserRule getRule() { return rule; }
		
		//sp=Scope oc=(AtomicIndicator | CompoundIndicator)
		public Group getGroup() { return cGroup; }
		
		//sp=Scope
		public Assignment getSpAssignment_0() { return cSpAssignment_0; }
		
		//Scope
		public RuleCall getSpScopeParserRuleCall_0_0() { return cSpScopeParserRuleCall_0_0; }
		
		//oc=(AtomicIndicator | CompoundIndicator)
		public Assignment getOcAssignment_1() { return cOcAssignment_1; }
		
		//(AtomicIndicator | CompoundIndicator)
		public Alternatives getOcAlternatives_1_0() { return cOcAlternatives_1_0; }
		
		//AtomicIndicator
		public RuleCall getOcAtomicIndicatorParserRuleCall_1_0_0() { return cOcAtomicIndicatorParserRuleCall_1_0_0; }
		
		//CompoundIndicator
		public RuleCall getOcCompoundIndicatorParserRuleCall_1_0_1() { return cOcCompoundIndicatorParserRuleCall_1_0_1; }
	}
	public class AtomicIndicatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.AtomicIndicator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEachKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cRobotKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOcAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOcOccurenceParserRuleCall_2_0 = (RuleCall)cOcAssignment_2.eContents().get(0);
		
		//AtomicIndicator:
		//	'each' 'robot' oc=Occurence;
		@Override public ParserRule getRule() { return rule; }
		
		//'each' 'robot' oc=Occurence
		public Group getGroup() { return cGroup; }
		
		//'each'
		public Keyword getEachKeyword_0() { return cEachKeyword_0; }
		
		//'robot'
		public Keyword getRobotKeyword_1() { return cRobotKeyword_1; }
		
		//oc=Occurence
		public Assignment getOcAssignment_2() { return cOcAssignment_2; }
		
		//Occurence
		public RuleCall getOcOccurenceParserRuleCall_2_0() { return cOcOccurenceParserRuleCall_2_0; }
	}
	public class CompoundIndicatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.CompoundIndicator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTheKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cSwarmKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOcAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOcOccurenceParserRuleCall_2_0 = (RuleCall)cOcAssignment_2.eContents().get(0);
		
		//CompoundIndicator:
		//	'the' 'swarm' oc=Occurence;
		@Override public ParserRule getRule() { return rule; }
		
		//'the' 'swarm' oc=Occurence
		public Group getGroup() { return cGroup; }
		
		//'the'
		public Keyword getTheKeyword_0() { return cTheKeyword_0; }
		
		//'swarm'
		public Keyword getSwarmKeyword_1() { return cSwarmKeyword_1; }
		
		//oc=Occurence
		public Assignment getOcAssignment_2() { return cOcAssignment_2; }
		
		//Occurence
		public RuleCall getOcOccurenceParserRuleCall_2_0() { return cOcOccurenceParserRuleCall_2_0; }
	}
	public class ScopeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Scope");
		private final Assignment cSpAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cSpAlternatives_0 = (Alternatives)cSpAssignment.eContents().get(0);
		private final Keyword cSpAtAnyPointOfTimeKeyword_0_0 = (Keyword)cSpAlternatives_0.eContents().get(0);
		private final Keyword cSpAtTheEndOfTheMissionKeyword_0_1 = (Keyword)cSpAlternatives_0.eContents().get(1);
		
		//Scope:
		//	sp=("At any point of time" | "At the end of the mission");
		@Override public ParserRule getRule() { return rule; }
		
		//sp=("At any point of time" | "At the end of the mission")
		public Assignment getSpAssignment() { return cSpAssignment; }
		
		//("At any point of time" | "At the end of the mission")
		public Alternatives getSpAlternatives_0() { return cSpAlternatives_0; }
		
		//"At any point of time"
		public Keyword getSpAtAnyPointOfTimeKeyword_0_0() { return cSpAtAnyPointOfTimeKeyword_0_0; }
		
		//"At the end of the mission"
		public Keyword getSpAtTheEndOfTheMissionKeyword_0_1() { return cSpAtTheEndOfTheMissionKeyword_0_1; }
	}
	public class AtomicEventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.AtomicEvent");
		private final Keyword cWallsChangeColorKeyword = (Keyword)rule.eContents().get(1);
		
		//AtomicEvent:
		//	'Walls change color';
		@Override public ParserRule getRule() { return rule; }
		
		//'Walls change color'
		public Keyword getWallsChangeColorKeyword() { return cWallsChangeColorKeyword; }
	}
	public class OccurenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Occurence");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRewardParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPenaltyParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Occurence:
		//	Reward | Penalty;
		@Override public ParserRule getRule() { return rule; }
		
		//Reward | Penalty
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Reward
		public RuleCall getRewardParserRuleCall_0() { return cRewardParserRuleCall_0; }
		
		//Penalty
		public RuleCall getPenaltyParserRuleCall_1() { return cPenaltyParserRuleCall_1; }
	}
	public class PenaltyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Penalty");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGetsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cAKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cPenaltyKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cKAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cKDoubleParserRuleCall_3_0 = (RuleCall)cKAssignment_3.eContents().get(0);
		private final Assignment cCAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCConditionParserRuleCall_4_0 = (RuleCall)cCAssignment_4.eContents().get(0);
		
		//Penalty:
		//	'gets' 'a' 'penalty' k=Double c=Condition;
		@Override public ParserRule getRule() { return rule; }
		
		//'gets' 'a' 'penalty' k=Double c=Condition
		public Group getGroup() { return cGroup; }
		
		//'gets'
		public Keyword getGetsKeyword_0() { return cGetsKeyword_0; }
		
		//'a'
		public Keyword getAKeyword_1() { return cAKeyword_1; }
		
		//'penalty'
		public Keyword getPenaltyKeyword_2() { return cPenaltyKeyword_2; }
		
		//k=Double
		public Assignment getKAssignment_3() { return cKAssignment_3; }
		
		//Double
		public RuleCall getKDoubleParserRuleCall_3_0() { return cKDoubleParserRuleCall_3_0; }
		
		//c=Condition
		public Assignment getCAssignment_4() { return cCAssignment_4; }
		
		//Condition
		public RuleCall getCConditionParserRuleCall_4_0() { return cCConditionParserRuleCall_4_0; }
	}
	public class RewardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Reward");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGetsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cAKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cRewardKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cKAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cKDoubleParserRuleCall_3_0 = (RuleCall)cKAssignment_3.eContents().get(0);
		private final Assignment cCAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCConditionParserRuleCall_4_0 = (RuleCall)cCAssignment_4.eContents().get(0);
		
		//Reward:
		//	'gets' 'a' 'reward' k=Double c=Condition;
		@Override public ParserRule getRule() { return rule; }
		
		//'gets' 'a' 'reward' k=Double c=Condition
		public Group getGroup() { return cGroup; }
		
		//'gets'
		public Keyword getGetsKeyword_0() { return cGetsKeyword_0; }
		
		//'a'
		public Keyword getAKeyword_1() { return cAKeyword_1; }
		
		//'reward'
		public Keyword getRewardKeyword_2() { return cRewardKeyword_2; }
		
		//k=Double
		public Assignment getKAssignment_3() { return cKAssignment_3; }
		
		//Double
		public RuleCall getKDoubleParserRuleCall_3_0() { return cKDoubleParserRuleCall_3_0; }
		
		//c=Condition
		public Assignment getCAssignment_4() { return cCAssignment_4; }
		
		//Condition
		public RuleCall getCConditionParserRuleCall_4_0() { return cCConditionParserRuleCall_4_0; }
	}
	public class ConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Condition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cIfKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cItKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cIsKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Keyword cOnKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Keyword cTheKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Assignment cRAssignment_0_5 = (Assignment)cGroup_0.eContents().get(5);
		private final RuleCall cRRegionParserRuleCall_0_5_0 = (RuleCall)cRAssignment_0_5.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cIfKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cThereKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cAreKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Keyword cMoreKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Keyword cThanKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Assignment cNAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cNINTTerminalRuleCall_1_5_0 = (RuleCall)cNAssignment_1_5.eContents().get(0);
		private final Keyword cRobotsKeyword_1_6 = (Keyword)cGroup_1.eContents().get(6);
		private final Keyword cOnKeyword_1_7 = (Keyword)cGroup_1.eContents().get(7);
		private final Keyword cTheKeyword_1_8 = (Keyword)cGroup_1.eContents().get(8);
		private final Assignment cRAssignment_1_9 = (Assignment)cGroup_1.eContents().get(9);
		private final RuleCall cRRegionParserRuleCall_1_9_0 = (RuleCall)cRAssignment_1_9.eContents().get(0);
		
		//Condition:
		//	'if' 'it' 'is' 'on' 'the' r=Region |
		//	'if' 'there' 'are' 'more' 'than' n=INT 'robots' 'on' 'the' r=Region;
		@Override public ParserRule getRule() { return rule; }
		
		//'if' 'it' 'is' 'on' 'the' r=Region | 'if' 'there' 'are' 'more' 'than' n=INT 'robots' 'on' 'the' r=Region
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'if' 'it' 'is' 'on' 'the' r=Region
		public Group getGroup_0() { return cGroup_0; }
		
		//'if'
		public Keyword getIfKeyword_0_0() { return cIfKeyword_0_0; }
		
		//'it'
		public Keyword getItKeyword_0_1() { return cItKeyword_0_1; }
		
		//'is'
		public Keyword getIsKeyword_0_2() { return cIsKeyword_0_2; }
		
		//'on'
		public Keyword getOnKeyword_0_3() { return cOnKeyword_0_3; }
		
		//'the'
		public Keyword getTheKeyword_0_4() { return cTheKeyword_0_4; }
		
		//r=Region
		public Assignment getRAssignment_0_5() { return cRAssignment_0_5; }
		
		//Region
		public RuleCall getRRegionParserRuleCall_0_5_0() { return cRRegionParserRuleCall_0_5_0; }
		
		//'if' 'there' 'are' 'more' 'than' n=INT 'robots' 'on' 'the' r=Region
		public Group getGroup_1() { return cGroup_1; }
		
		//'if'
		public Keyword getIfKeyword_1_0() { return cIfKeyword_1_0; }
		
		//'there'
		public Keyword getThereKeyword_1_1() { return cThereKeyword_1_1; }
		
		//'are'
		public Keyword getAreKeyword_1_2() { return cAreKeyword_1_2; }
		
		//'more'
		public Keyword getMoreKeyword_1_3() { return cMoreKeyword_1_3; }
		
		//'than'
		public Keyword getThanKeyword_1_4() { return cThanKeyword_1_4; }
		
		//n=INT
		public Assignment getNAssignment_1_5() { return cNAssignment_1_5; }
		
		//INT
		public RuleCall getNINTTerminalRuleCall_1_5_0() { return cNINTTerminalRuleCall_1_5_0; }
		
		//'robots'
		public Keyword getRobotsKeyword_1_6() { return cRobotsKeyword_1_6; }
		
		//'on'
		public Keyword getOnKeyword_1_7() { return cOnKeyword_1_7; }
		
		//'the'
		public Keyword getTheKeyword_1_8() { return cTheKeyword_1_8; }
		
		//r=Region
		public Assignment getRAssignment_1_9() { return cRAssignment_1_9; }
		
		//Region
		public RuleCall getRRegionParserRuleCall_1_9_0() { return cRRegionParserRuleCall_1_9_0; }
	}
	public class TimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Time");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cXAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cXLiteralParserRuleCall_0_0 = (RuleCall)cXAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cBegginingKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cOfKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cTheKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Keyword cMissionKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cEndKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cOfKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cTheKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cMissionKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		
		//Time:
		//	x=Literal | 'beggining' 'of' 'the' 'mission' | 'end' 'of' 'the' 'mission';
		@Override public ParserRule getRule() { return rule; }
		
		//x=Literal | 'beggining' 'of' 'the' 'mission' | 'end' 'of' 'the' 'mission'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//x=Literal
		public Assignment getXAssignment_0() { return cXAssignment_0; }
		
		//Literal
		public RuleCall getXLiteralParserRuleCall_0_0() { return cXLiteralParserRuleCall_0_0; }
		
		//'beggining' 'of' 'the' 'mission'
		public Group getGroup_1() { return cGroup_1; }
		
		//'beggining'
		public Keyword getBegginingKeyword_1_0() { return cBegginingKeyword_1_0; }
		
		//'of'
		public Keyword getOfKeyword_1_1() { return cOfKeyword_1_1; }
		
		//'the'
		public Keyword getTheKeyword_1_2() { return cTheKeyword_1_2; }
		
		//'mission'
		public Keyword getMissionKeyword_1_3() { return cMissionKeyword_1_3; }
		
		//'end' 'of' 'the' 'mission'
		public Group getGroup_2() { return cGroup_2; }
		
		//'end'
		public Keyword getEndKeyword_2_0() { return cEndKeyword_2_0; }
		
		//'of'
		public Keyword getOfKeyword_2_1() { return cOfKeyword_2_1; }
		
		//'the'
		public Keyword getTheKeyword_2_2() { return cTheKeyword_2_2; }
		
		//'mission'
		public Keyword getMissionKeyword_2_3() { return cMissionKeyword_2_3; }
	}
	public class RobotElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Robot");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEPuckKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFootBootKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//Robot:
		//	'e-puck' | 'foot-boot';
		@Override public ParserRule getRule() { return rule; }
		
		//'e-puck' | 'foot-boot'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'e-puck'
		public Keyword getEPuckKeyword_0() { return cEPuckKeyword_0; }
		
		//'foot-boot'
		public Keyword getFootBootKeyword_1() { return cFootBootKeyword_1; }
	}
	public class DistributionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Distribution");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cUniformKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cGaussianKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cConstantKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//Distribution:
		//	'uniform' | 'gaussian' | 'constant';
		@Override public ParserRule getRule() { return rule; }
		
		//'uniform' | 'gaussian' | 'constant'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'uniform'
		public Keyword getUniformKeyword_0() { return cUniformKeyword_0; }
		
		//'gaussian'
		public Keyword getGaussianKeyword_1() { return cGaussianKeyword_1; }
		
		//'constant'
		public Keyword getConstantKeyword_2() { return cConstantKeyword_2; }
	}
	public class EnvironmentElementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.EnvironmentElements");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEnvironmentElementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cElementDescriptionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EnvironmentElements:
		//	EnvironmentElement | ElementDescription;
		@Override public ParserRule getRule() { return rule; }
		
		//EnvironmentElement | ElementDescription
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EnvironmentElement
		public RuleCall getEnvironmentElementParserRuleCall_0() { return cEnvironmentElementParserRuleCall_0; }
		
		//ElementDescription
		public RuleCall getElementDescriptionParserRuleCall_1() { return cElementDescriptionParserRuleCall_1; }
	}
	public class EnvironmentElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.EnvironmentElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cObstacleParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLightParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cObjectParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//EnvironmentElement:
		//	Obstacle | Light | Object;
		@Override public ParserRule getRule() { return rule; }
		
		//Obstacle | Light | Object
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Obstacle
		public RuleCall getObstacleParserRuleCall_0() { return cObstacleParserRuleCall_0; }
		
		//Light
		public RuleCall getLightParserRuleCall_1() { return cLightParserRuleCall_1; }
		
		//Object
		public RuleCall getObjectParserRuleCall_2() { return cObjectParserRuleCall_2; }
	}
	public class ElementDescriptionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.ElementDescription");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cElAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cElThereKeyword_0_0 = (Keyword)cElAssignment_0.eContents().get(0);
		private final Keyword cAreKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cXAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cXRangeParserRuleCall_2_0 = (RuleCall)cXAssignment_2.eContents().get(0);
		private final Assignment cObjAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cObjElementParserRuleCall_3_0 = (RuleCall)cObjAssignment_3.eContents().get(0);
		private final Assignment cRAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRProbabilisticDecriptionParserRuleCall_4_0 = (RuleCall)cRAssignment_4.eContents().get(0);
		
		//ElementDescription:
		//	el='There' 'are' x=Range obj=Element r=ProbabilisticDecription;
		@Override public ParserRule getRule() { return rule; }
		
		//el='There' 'are' x=Range obj=Element r=ProbabilisticDecription
		public Group getGroup() { return cGroup; }
		
		//el='There'
		public Assignment getElAssignment_0() { return cElAssignment_0; }
		
		//'There'
		public Keyword getElThereKeyword_0_0() { return cElThereKeyword_0_0; }
		
		//'are'
		public Keyword getAreKeyword_1() { return cAreKeyword_1; }
		
		//x=Range
		public Assignment getXAssignment_2() { return cXAssignment_2; }
		
		//Range
		public RuleCall getXRangeParserRuleCall_2_0() { return cXRangeParserRuleCall_2_0; }
		
		//obj=Element
		public Assignment getObjAssignment_3() { return cObjAssignment_3; }
		
		//Element
		public RuleCall getObjElementParserRuleCall_3_0() { return cObjElementParserRuleCall_3_0; }
		
		//r=ProbabilisticDecription
		public Assignment getRAssignment_4() { return cRAssignment_4; }
		
		//ProbabilisticDecription
		public RuleCall getRProbabilisticDecriptionParserRuleCall_4_0() { return cRProbabilisticDecriptionParserRuleCall_4_0; }
	}
	public class ElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Element");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cObjectsKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cObstaclesKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLightKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cSourcesKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		
		//Element:
		//	'objects' | 'obstacles' | 'light' 'sources';
		@Override public ParserRule getRule() { return rule; }
		
		//'objects' | 'obstacles' | 'light' 'sources'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'objects'
		public Keyword getObjectsKeyword_0() { return cObjectsKeyword_0; }
		
		//'obstacles'
		public Keyword getObstaclesKeyword_1() { return cObstaclesKeyword_1; }
		
		//'light' 'sources'
		public Group getGroup_2() { return cGroup_2; }
		
		//'light'
		public Keyword getLightKeyword_2_0() { return cLightKeyword_2_0; }
		
		//'sources'
		public Keyword getSourcesKeyword_2_1() { return cSourcesKeyword_2_1; }
	}
	public class ObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Object");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cObjAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cObjAnKeyword_0_0 = (Keyword)cObjAssignment_0.eContents().get(0);
		private final Keyword cObjectKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cAKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRRegionParserRuleCall_4_0 = (RuleCall)cRAssignment_4.eContents().get(0);
		
		//Object:
		//	obj='An' 'object' 'as' 'a' r=Region;
		@Override public ParserRule getRule() { return rule; }
		
		//obj='An' 'object' 'as' 'a' r=Region
		public Group getGroup() { return cGroup; }
		
		//obj='An'
		public Assignment getObjAssignment_0() { return cObjAssignment_0; }
		
		//'An'
		public Keyword getObjAnKeyword_0_0() { return cObjAnKeyword_0_0; }
		
		//'object'
		public Keyword getObjectKeyword_1() { return cObjectKeyword_1; }
		
		//'as'
		public Keyword getAsKeyword_2() { return cAsKeyword_2; }
		
		//'a'
		public Keyword getAKeyword_3() { return cAKeyword_3; }
		
		//r=Region
		public Assignment getRAssignment_4() { return cRAssignment_4; }
		
		//Region
		public RuleCall getRRegionParserRuleCall_4_0() { return cRRegionParserRuleCall_4_0; }
	}
	public class ObstacleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Obstacle");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cObsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cObsAnKeyword_0_0 = (Keyword)cObsAssignment_0.eContents().get(0);
		private final Keyword cObstacleKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cAKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRRegionParserRuleCall_4_0 = (RuleCall)cRAssignment_4.eContents().get(0);
		
		//Obstacle:
		//	obs='An' 'obstacle' 'as' 'a' r=Region;
		@Override public ParserRule getRule() { return rule; }
		
		////shape=Shape*
		////dimensions=Dimension
		////position=Position
		//obs='An' 'obstacle' 'as' 'a' r=Region
		public Group getGroup() { return cGroup; }
		
		////shape=Shape*
		////dimensions=Dimension
		////position=Position
		//obs='An'
		public Assignment getObsAssignment_0() { return cObsAssignment_0; }
		
		//'An'
		public Keyword getObsAnKeyword_0_0() { return cObsAnKeyword_0_0; }
		
		//'obstacle'
		public Keyword getObstacleKeyword_1() { return cObstacleKeyword_1; }
		
		//'as'
		public Keyword getAsKeyword_2() { return cAsKeyword_2; }
		
		//'a'
		public Keyword getAKeyword_3() { return cAKeyword_3; }
		
		//r=Region
		public Assignment getRAssignment_4() { return cRAssignment_4; }
		
		//Region
		public RuleCall getRRegionParserRuleCall_4_0() { return cRRegionParserRuleCall_4_0; }
	}
	public class LightElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Light");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cLAKeyword_0_0 = (Keyword)cLAssignment_0.eContents().get(0);
		private final Keyword cLightKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cSourceKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cEmittingKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cAKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCColorParserRuleCall_5_0 = (RuleCall)cCAssignment_5.eContents().get(0);
		private final Keyword cLightKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cIsKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cPlacedKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Keyword cInKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Keyword cAKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Assignment cPAssignment_11 = (Assignment)cGroup.eContents().get(11);
		private final RuleCall cPPositionParserRuleCall_11_0 = (RuleCall)cPAssignment_11.eContents().get(0);
		
		//Light:
		//	l='A' 'light' 'source' 'emitting' 'a' c=Color 'light' 'is' 'placed' 'in' 'a' p=Position;
		@Override public ParserRule getRule() { return rule; }
		
		//l='A' 'light' 'source' 'emitting' 'a' c=Color 'light' 'is' 'placed' 'in' 'a' p=Position
		public Group getGroup() { return cGroup; }
		
		//l='A'
		public Assignment getLAssignment_0() { return cLAssignment_0; }
		
		//'A'
		public Keyword getLAKeyword_0_0() { return cLAKeyword_0_0; }
		
		//'light'
		public Keyword getLightKeyword_1() { return cLightKeyword_1; }
		
		//'source'
		public Keyword getSourceKeyword_2() { return cSourceKeyword_2; }
		
		//'emitting'
		public Keyword getEmittingKeyword_3() { return cEmittingKeyword_3; }
		
		//'a'
		public Keyword getAKeyword_4() { return cAKeyword_4; }
		
		//c=Color
		public Assignment getCAssignment_5() { return cCAssignment_5; }
		
		//Color
		public RuleCall getCColorParserRuleCall_5_0() { return cCColorParserRuleCall_5_0; }
		
		//'light'
		public Keyword getLightKeyword_6() { return cLightKeyword_6; }
		
		//'is'
		public Keyword getIsKeyword_7() { return cIsKeyword_7; }
		
		//'placed'
		public Keyword getPlacedKeyword_8() { return cPlacedKeyword_8; }
		
		//'in'
		public Keyword getInKeyword_9() { return cInKeyword_9; }
		
		//'a'
		public Keyword getAKeyword_10() { return cAKeyword_10; }
		
		//p=Position
		public Assignment getPAssignment_11() { return cPAssignment_11; }
		
		//Position
		public RuleCall getPPositionParserRuleCall_11_0() { return cPPositionParserRuleCall_11_0; }
	}
	public class PositionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Position");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cCircleAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cCenterKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cPointAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cPointCoordinateParserRuleCall_0_2_0 = (RuleCall)cPointAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cRectangleAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cReferencePointKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cPointAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cPointCoordinateParserRuleCall_1_2_0 = (RuleCall)cPointAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cPointDAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cPointKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cPointAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cPointCoordinateParserRuleCall_2_2_0 = (RuleCall)cPointAssignment_2_2.eContents().get(0);
		
		//Position:
		//	{Circle} 'center' point=Coordinate | {Rectangle} 'reference point' point=Coordinate | {PointD} 'point'
		//	point=Coordinate;
		@Override public ParserRule getRule() { return rule; }
		
		//{Circle} 'center' point=Coordinate | {Rectangle} 'reference point' point=Coordinate | {PointD} 'point' point=Coordinate
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{Circle} 'center' point=Coordinate
		public Group getGroup_0() { return cGroup_0; }
		
		//{Circle}
		public Action getCircleAction_0_0() { return cCircleAction_0_0; }
		
		//'center'
		public Keyword getCenterKeyword_0_1() { return cCenterKeyword_0_1; }
		
		//point=Coordinate
		public Assignment getPointAssignment_0_2() { return cPointAssignment_0_2; }
		
		//Coordinate
		public RuleCall getPointCoordinateParserRuleCall_0_2_0() { return cPointCoordinateParserRuleCall_0_2_0; }
		
		//{Rectangle} 'reference point' point=Coordinate
		public Group getGroup_1() { return cGroup_1; }
		
		//{Rectangle}
		public Action getRectangleAction_1_0() { return cRectangleAction_1_0; }
		
		//'reference point'
		public Keyword getReferencePointKeyword_1_1() { return cReferencePointKeyword_1_1; }
		
		//point=Coordinate
		public Assignment getPointAssignment_1_2() { return cPointAssignment_1_2; }
		
		//Coordinate
		public RuleCall getPointCoordinateParserRuleCall_1_2_0() { return cPointCoordinateParserRuleCall_1_2_0; }
		
		//{PointD} 'point' point=Coordinate
		public Group getGroup_2() { return cGroup_2; }
		
		//{PointD}
		public Action getPointDAction_2_0() { return cPointDAction_2_0; }
		
		//'point'
		public Keyword getPointKeyword_2_1() { return cPointKeyword_2_1; }
		
		//point=Coordinate
		public Assignment getPointAssignment_2_2() { return cPointAssignment_2_2; }
		
		//Coordinate
		public RuleCall getPointCoordinateParserRuleCall_2_2_0() { return cPointCoordinateParserRuleCall_2_2_0; }
	}
	public class ShapeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Shape");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cCircleKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPolygonKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cTriangleKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cRectangleKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//Shape:
		//	'Circle' | 'Polygon' | 'Triangle' | 'Rectangle';
		@Override public ParserRule getRule() { return rule; }
		
		//'Circle' | 'Polygon' | 'Triangle' | 'Rectangle'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'Circle'
		public Keyword getCircleKeyword_0() { return cCircleKeyword_0; }
		
		//'Polygon'
		public Keyword getPolygonKeyword_1() { return cPolygonKeyword_1; }
		
		//'Triangle'
		public Keyword getTriangleKeyword_2() { return cTriangleKeyword_2; }
		
		//'Rectangle'
		public Keyword getRectangleKeyword_3() { return cRectangleKeyword_3; }
	}
	public class ArenaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Arena");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTheKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cArenaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cIsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cAKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cSAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cSRegionParserRuleCall_4_0 = (RuleCall)cSAssignment_4.eContents().get(0);
		
		//Arena:
		//	'The' 'arena' 'is' 'a' s=Region;
		@Override public ParserRule getRule() { return rule; }
		
		//'The' 'arena' 'is' 'a' s=Region
		public Group getGroup() { return cGroup; }
		
		//'The'
		public Keyword getTheKeyword_0() { return cTheKeyword_0; }
		
		//'arena'
		public Keyword getArenaKeyword_1() { return cArenaKeyword_1; }
		
		//'is'
		public Keyword getIsKeyword_2() { return cIsKeyword_2; }
		
		//'a'
		public Keyword getAKeyword_3() { return cAKeyword_3; }
		
		//s=Region
		public Assignment getSAssignment_4() { return cSAssignment_4; }
		
		//Region
		public RuleCall getSRegionParserRuleCall_4_0() { return cSRegionParserRuleCall_4_0; }
	}
	public class ColorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Color");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cRedKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cYellowKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cGreenKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		////. 'with' dimensions=Dimension;
		//Color:
		//	'red' | 'yellow' | 'green';
		@Override public ParserRule getRule() { return rule; }
		
		//'red' | 'yellow' | 'green'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'red'
		public Keyword getRedKeyword_0() { return cRedKeyword_0; }
		
		//'yellow'
		public Keyword getYellowKeyword_1() { return cYellowKeyword_1; }
		
		//'green'
		public Keyword getGreenKeyword_2() { return cGreenKeyword_2; }
	}
	public class RegionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Region");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cColorsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cColorsColorParserRuleCall_0_0 = (RuleCall)cColorsAssignment_0.eContents().get(0);
		private final Assignment cShapeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cShapeShapeParserRuleCall_1_0 = (RuleCall)cShapeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cWithKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cReferencepointAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cReferencepointPositionParserRuleCall_3_1_0 = (RuleCall)cReferencepointAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cAndKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cDimensionsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cDimensionsDimensionParserRuleCall_4_1_0 = (RuleCall)cDimensionsAssignment_4_1.eContents().get(0);
		
		////Region:
		//// 'Circle' | 'Polygon';
		//Region:
		//	colors=Color? shape=Shape? name=ID ('with' referencepoint=Position)? ('and' dimensions=Dimension)?;
		@Override public ParserRule getRule() { return rule; }
		
		//colors=Color? shape=Shape? name=ID ('with' referencepoint=Position)? ('and' dimensions=Dimension)?
		public Group getGroup() { return cGroup; }
		
		//colors=Color?
		public Assignment getColorsAssignment_0() { return cColorsAssignment_0; }
		
		//Color
		public RuleCall getColorsColorParserRuleCall_0_0() { return cColorsColorParserRuleCall_0_0; }
		
		//shape=Shape?
		public Assignment getShapeAssignment_1() { return cShapeAssignment_1; }
		
		//Shape
		public RuleCall getShapeShapeParserRuleCall_1_0() { return cShapeShapeParserRuleCall_1_0; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//('with' referencepoint=Position)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'with'
		public Keyword getWithKeyword_3_0() { return cWithKeyword_3_0; }
		
		//referencepoint=Position
		public Assignment getReferencepointAssignment_3_1() { return cReferencepointAssignment_3_1; }
		
		//Position
		public RuleCall getReferencepointPositionParserRuleCall_3_1_0() { return cReferencepointPositionParserRuleCall_3_1_0; }
		
		//('and' dimensions=Dimension)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'and'
		public Keyword getAndKeyword_4_0() { return cAndKeyword_4_0; }
		
		//dimensions=Dimension
		public Assignment getDimensionsAssignment_4_1() { return cDimensionsAssignment_4_1; }
		
		//Dimension
		public RuleCall getDimensionsDimensionParserRuleCall_4_1_0() { return cDimensionsDimensionParserRuleCall_4_1_0; }
	}
	public class DimensionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Dimension");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCircleDParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRectangleDParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////Type: 
		////	CircleD | RectangleD	
		////;
		//Dimension:
		//	CircleD | RectangleD;
		@Override public ParserRule getRule() { return rule; }
		
		//CircleD | RectangleD
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CircleD
		public RuleCall getCircleDParserRuleCall_0() { return cCircleDParserRuleCall_0; }
		
		//RectangleD
		public RuleCall getRectangleDParserRuleCall_1() { return cRectangleDParserRuleCall_1; }
	}
	public class CircleDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.CircleD");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRadiusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRDoubleParserRuleCall_1_0 = (RuleCall)cRAssignment_1.eContents().get(0);
		
		////{CircleD} 'radius' r=Double | 
		////{RectangleD} 'length' l=Double ',width' w=Double 'and' 'height' h=Double ; //|
		////types=[CircleD | ]
		////{SquareD} 'side' a=Double;
		//CircleD:
		//	'radius' r=Double;
		@Override public ParserRule getRule() { return rule; }
		
		//'radius' r=Double
		public Group getGroup() { return cGroup; }
		
		//'radius'
		public Keyword getRadiusKeyword_0() { return cRadiusKeyword_0; }
		
		//r=Double
		public Assignment getRAssignment_1() { return cRAssignment_1; }
		
		//Double
		public RuleCall getRDoubleParserRuleCall_1_0() { return cRDoubleParserRuleCall_1_0; }
	}
	public class RectangleDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.RectangleD");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLengthKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLDoubleParserRuleCall_1_0 = (RuleCall)cLAssignment_1.eContents().get(0);
		private final Keyword cWidthKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cWAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cWDoubleParserRuleCall_3_0 = (RuleCall)cWAssignment_3.eContents().get(0);
		private final Keyword cAndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cHeightKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cHAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cHDoubleParserRuleCall_6_0 = (RuleCall)cHAssignment_6.eContents().get(0);
		
		//RectangleD:
		//	'length' l=Double ',width' w=Double 'and' 'height' h=Double;
		@Override public ParserRule getRule() { return rule; }
		
		//'length' l=Double ',width' w=Double 'and' 'height' h=Double
		public Group getGroup() { return cGroup; }
		
		//'length'
		public Keyword getLengthKeyword_0() { return cLengthKeyword_0; }
		
		//l=Double
		public Assignment getLAssignment_1() { return cLAssignment_1; }
		
		//Double
		public RuleCall getLDoubleParserRuleCall_1_0() { return cLDoubleParserRuleCall_1_0; }
		
		//',width'
		public Keyword getWidthKeyword_2() { return cWidthKeyword_2; }
		
		//w=Double
		public Assignment getWAssignment_3() { return cWAssignment_3; }
		
		//Double
		public RuleCall getWDoubleParserRuleCall_3_0() { return cWDoubleParserRuleCall_3_0; }
		
		//'and'
		public Keyword getAndKeyword_4() { return cAndKeyword_4; }
		
		//'height'
		public Keyword getHeightKeyword_5() { return cHeightKeyword_5; }
		
		//h=Double
		public Assignment getHAssignment_6() { return cHAssignment_6; }
		
		//Double
		public RuleCall getHDoubleParserRuleCall_6_0() { return cHDoubleParserRuleCall_6_0; }
	}
	public class CoordinateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Coordinate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cXAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cXDoubleParserRuleCall_0_0 = (RuleCall)cXAssignment_0.eContents().get(0);
		private final Assignment cYAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cYDoubleParserRuleCall_1_0 = (RuleCall)cYAssignment_1.eContents().get(0);
		
		//Coordinate:
		//	x=Double y=Double;
		@Override public ParserRule getRule() { return rule; }
		
		//x=Double y=Double
		public Group getGroup() { return cGroup; }
		
		//x=Double
		public Assignment getXAssignment_0() { return cXAssignment_0; }
		
		//Double
		public RuleCall getXDoubleParserRuleCall_0_0() { return cXDoubleParserRuleCall_0_0; }
		
		//y=Double
		public Assignment getYAssignment_1() { return cYAssignment_1; }
		
		//Double
		public RuleCall getYDoubleParserRuleCall_1_0() { return cYDoubleParserRuleCall_1_0; }
	}
	public class DoubleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Double");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Double:
		//	INT '.' INT;
		@Override public ParserRule getRule() { return rule; }
		
		//INT '.' INT
		public Group getGroup() { return cGroup; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
	}
	public class RangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Range");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUpperboundParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLowerboundParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntervalParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLowerorEqualboundParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cUpperorEqualboundParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cConstantSizeParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//Range:
		//	Upperbound | Lowerbound | Interval | LowerorEqualbound | UpperorEqualbound | ConstantSize;
		@Override public ParserRule getRule() { return rule; }
		
		//Upperbound | Lowerbound | Interval | LowerorEqualbound | UpperorEqualbound | ConstantSize
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Upperbound
		public RuleCall getUpperboundParserRuleCall_0() { return cUpperboundParserRuleCall_0; }
		
		//Lowerbound
		public RuleCall getLowerboundParserRuleCall_1() { return cLowerboundParserRuleCall_1; }
		
		//Interval
		public RuleCall getIntervalParserRuleCall_2() { return cIntervalParserRuleCall_2; }
		
		//LowerorEqualbound
		public RuleCall getLowerorEqualboundParserRuleCall_3() { return cLowerorEqualboundParserRuleCall_3; }
		
		//UpperorEqualbound
		public RuleCall getUpperorEqualboundParserRuleCall_4() { return cUpperorEqualboundParserRuleCall_4; }
		
		//ConstantSize
		public RuleCall getConstantSizeParserRuleCall_5() { return cConstantSizeParserRuleCall_5; }
	}
	public class ConstantSizeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.ConstantSize");
		private final Assignment cNAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNINTTerminalRuleCall_0 = (RuleCall)cNAssignment.eContents().get(0);
		
		//ConstantSize:
		//	n=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//n=INT
		public Assignment getNAssignment() { return cNAssignment; }
		
		//INT
		public RuleCall getNINTTerminalRuleCall_0() { return cNINTTerminalRuleCall_0; }
	}
	public class LowerboundElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Lowerbound");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cThanKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNINTTerminalRuleCall_2_0 = (RuleCall)cNAssignment_2.eContents().get(0);
		
		//Lowerbound:
		//	'less' 'than' n=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//'less' 'than' n=INT
		public Group getGroup() { return cGroup; }
		
		//'less'
		public Keyword getLessKeyword_0() { return cLessKeyword_0; }
		
		//'than'
		public Keyword getThanKeyword_1() { return cThanKeyword_1; }
		
		//n=INT
		public Assignment getNAssignment_2() { return cNAssignment_2; }
		
		//INT
		public RuleCall getNINTTerminalRuleCall_2_0() { return cNINTTerminalRuleCall_2_0; }
	}
	public class LowerorEqualboundElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.LowerorEqualbound");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cOrKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cThanKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNINTTerminalRuleCall_4_0 = (RuleCall)cNAssignment_4.eContents().get(0);
		
		//LowerorEqualbound:
		//	'less' 'or' 'equal' 'than' n=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//'less' 'or' 'equal' 'than' n=INT
		public Group getGroup() { return cGroup; }
		
		//'less'
		public Keyword getLessKeyword_0() { return cLessKeyword_0; }
		
		//'or'
		public Keyword getOrKeyword_1() { return cOrKeyword_1; }
		
		//'equal'
		public Keyword getEqualKeyword_2() { return cEqualKeyword_2; }
		
		//'than'
		public Keyword getThanKeyword_3() { return cThanKeyword_3; }
		
		//n=INT
		public Assignment getNAssignment_4() { return cNAssignment_4; }
		
		//INT
		public RuleCall getNINTTerminalRuleCall_4_0() { return cNINTTerminalRuleCall_4_0; }
	}
	public class UpperboundElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Upperbound");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMoreKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cThanKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNINTTerminalRuleCall_2_0 = (RuleCall)cNAssignment_2.eContents().get(0);
		
		//Upperbound:
		//	'more' 'than' n=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//'more' 'than' n=INT
		public Group getGroup() { return cGroup; }
		
		//'more'
		public Keyword getMoreKeyword_0() { return cMoreKeyword_0; }
		
		//'than'
		public Keyword getThanKeyword_1() { return cThanKeyword_1; }
		
		//n=INT
		public Assignment getNAssignment_2() { return cNAssignment_2; }
		
		//INT
		public RuleCall getNINTTerminalRuleCall_2_0() { return cNINTTerminalRuleCall_2_0; }
	}
	public class UpperorEqualboundElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.UpperorEqualbound");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMoreKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cOrKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cThanKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNINTTerminalRuleCall_4_0 = (RuleCall)cNAssignment_4.eContents().get(0);
		
		//UpperorEqualbound:
		//	'more' 'or' 'equal' 'than' n=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//'more' 'or' 'equal' 'than' n=INT
		public Group getGroup() { return cGroup; }
		
		//'more'
		public Keyword getMoreKeyword_0() { return cMoreKeyword_0; }
		
		//'or'
		public Keyword getOrKeyword_1() { return cOrKeyword_1; }
		
		//'equal'
		public Keyword getEqualKeyword_2() { return cEqualKeyword_2; }
		
		//'than'
		public Keyword getThanKeyword_3() { return cThanKeyword_3; }
		
		//n=INT
		public Assignment getNAssignment_4() { return cNAssignment_4; }
		
		//INT
		public RuleCall getNINTTerminalRuleCall_4_0() { return cNINTTerminalRuleCall_4_0; }
	}
	public class IntervalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Interval");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBetweenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cMAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMINTTerminalRuleCall_1_0 = (RuleCall)cMAssignment_1.eContents().get(0);
		private final Keyword cAndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNINTTerminalRuleCall_3_0 = (RuleCall)cNAssignment_3.eContents().get(0);
		
		////
		//Interval:
		//	'between' m=INT 'and' n=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//'between' m=INT 'and' n=INT
		public Group getGroup() { return cGroup; }
		
		//'between'
		public Keyword getBetweenKeyword_0() { return cBetweenKeyword_0; }
		
		//m=INT
		public Assignment getMAssignment_1() { return cMAssignment_1; }
		
		//INT
		public RuleCall getMINTTerminalRuleCall_1_0() { return cMINTTerminalRuleCall_1_0; }
		
		//'and'
		public Keyword getAndKeyword_2() { return cAndKeyword_2; }
		
		//n=INT
		public Assignment getNAssignment_3() { return cNAssignment_3; }
		
		//INT
		public RuleCall getNINTTerminalRuleCall_3_0() { return cNINTTerminalRuleCall_3_0; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cIntLiteralKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cRealLiteralKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final RuleCall cBoolLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Literal ArithmeticExpression:
		//	'IntLiteral' | 'RealLiteral' | BoolLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//'IntLiteral' | 'RealLiteral' | BoolLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'IntLiteral'
		public Keyword getIntLiteralKeyword_0() { return cIntLiteralKeyword_0; }
		
		//'RealLiteral'
		public Keyword getRealLiteralKeyword_1() { return cRealLiteralKeyword_1; }
		
		//BoolLiteral
		public RuleCall getBoolLiteralParserRuleCall_2() { return cBoolLiteralParserRuleCall_2; }
	}
	public class BoolLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.sml.Sml.BoolLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cValueAlternatives_0 = (Alternatives)cValueAssignment.eContents().get(0);
		private final Keyword cValueTrueKeyword_0_0 = (Keyword)cValueAlternatives_0.eContents().get(0);
		private final Keyword cValueFalseKeyword_0_1 = (Keyword)cValueAlternatives_0.eContents().get(1);
		
		////IntLiteral:
		////value=SignedInt;
		////RealLiteral:
		////value=SignedReal;
		//BoolLiteral:
		//	value=('true' | 'false');
		@Override public ParserRule getRule() { return rule; }
		
		//value=('true' | 'false')
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//('true' | 'false')
		public Alternatives getValueAlternatives_0() { return cValueAlternatives_0; }
		
		//'true'
		public Keyword getValueTrueKeyword_0_0() { return cValueTrueKeyword_0_0; }
		
		//'false'
		public Keyword getValueFalseKeyword_0_1() { return cValueFalseKeyword_0_1; }
	}
	
	
	private final ModelElements pModel;
	private final EnvironmentElements pEnvironment;
	private final ProbabilisticDecriptionElements pProbabilisticDecription;
	private final SwarmconfElements pSwarmconf;
	private final MissionTimeElements pMissionTime;
	private final MissionElements pMission;
	private final TaskElements pTask;
	private final MetricElements pMetric;
	private final MissionObjectiveElements pMissionObjective;
	private final IndicatorElements pIndicator;
	private final AtomicIndicatorElements pAtomicIndicator;
	private final CompoundIndicatorElements pCompoundIndicator;
	private final ScopeElements pScope;
	private final AtomicEventElements pAtomicEvent;
	private final OccurenceElements pOccurence;
	private final PenaltyElements pPenalty;
	private final RewardElements pReward;
	private final ConditionElements pCondition;
	private final TimeElements pTime;
	private final RobotElements pRobot;
	private final DistributionElements pDistribution;
	private final EnvironmentElementsElements pEnvironmentElements;
	private final EnvironmentElementElements pEnvironmentElement;
	private final ElementDescriptionElements pElementDescription;
	private final ElementElements pElement;
	private final ObjectElements pObject;
	private final ObstacleElements pObstacle;
	private final LightElements pLight;
	private final PositionElements pPosition;
	private final ShapeElements pShape;
	private final ArenaElements pArena;
	private final ColorElements pColor;
	private final RegionElements pRegion;
	private final DimensionElements pDimension;
	private final CircleDElements pCircleD;
	private final RectangleDElements pRectangleD;
	private final CoordinateElements pCoordinate;
	private final DoubleElements pDouble;
	private final RangeElements pRange;
	private final ConstantSizeElements pConstantSize;
	private final LowerboundElements pLowerbound;
	private final LowerorEqualboundElements pLowerorEqualbound;
	private final UpperboundElements pUpperbound;
	private final UpperorEqualboundElements pUpperorEqualbound;
	private final IntervalElements pInterval;
	private final LiteralElements pLiteral;
	private final BoolLiteralElements pBoolLiteral;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public SmlGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pEnvironment = new EnvironmentElements();
		this.pProbabilisticDecription = new ProbabilisticDecriptionElements();
		this.pSwarmconf = new SwarmconfElements();
		this.pMissionTime = new MissionTimeElements();
		this.pMission = new MissionElements();
		this.pTask = new TaskElements();
		this.pMetric = new MetricElements();
		this.pMissionObjective = new MissionObjectiveElements();
		this.pIndicator = new IndicatorElements();
		this.pAtomicIndicator = new AtomicIndicatorElements();
		this.pCompoundIndicator = new CompoundIndicatorElements();
		this.pScope = new ScopeElements();
		this.pAtomicEvent = new AtomicEventElements();
		this.pOccurence = new OccurenceElements();
		this.pPenalty = new PenaltyElements();
		this.pReward = new RewardElements();
		this.pCondition = new ConditionElements();
		this.pTime = new TimeElements();
		this.pRobot = new RobotElements();
		this.pDistribution = new DistributionElements();
		this.pEnvironmentElements = new EnvironmentElementsElements();
		this.pEnvironmentElement = new EnvironmentElementElements();
		this.pElementDescription = new ElementDescriptionElements();
		this.pElement = new ElementElements();
		this.pObject = new ObjectElements();
		this.pObstacle = new ObstacleElements();
		this.pLight = new LightElements();
		this.pPosition = new PositionElements();
		this.pShape = new ShapeElements();
		this.pArena = new ArenaElements();
		this.pColor = new ColorElements();
		this.pRegion = new RegionElements();
		this.pDimension = new DimensionElements();
		this.pCircleD = new CircleDElements();
		this.pRectangleD = new RectangleDElements();
		this.pCoordinate = new CoordinateElements();
		this.pDouble = new DoubleElements();
		this.pRange = new RangeElements();
		this.pConstantSize = new ConstantSizeElements();
		this.pLowerbound = new LowerboundElements();
		this.pLowerorEqualbound = new LowerorEqualboundElements();
		this.pUpperbound = new UpperboundElements();
		this.pUpperorEqualbound = new UpperorEqualboundElements();
		this.pInterval = new IntervalElements();
		this.pLiteral = new LiteralElements();
		this.pBoolLiteral = new BoolLiteralElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.example.sml.Sml".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	arenas=Arena env=Environment sw=Swarmconf ob=MissionObjective;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//Environment:
	//	('The' 'arena' 'contains' 'the' 'following' 'elements' ':')? environment+=EnvironmentElements*;
	public EnvironmentElements getEnvironmentAccess() {
		return pEnvironment;
	}
	
	public ParserRule getEnvironmentRule() {
		return getEnvironmentAccess().getRule();
	}
	
	//ProbabilisticDecription:
	//	'distributed' 'with' 'a' dis=Distribution 'distribution' 'in' 'a' k=Region;
	public ProbabilisticDecriptionElements getProbabilisticDecriptionAccess() {
		return pProbabilisticDecription;
	}
	
	public ParserRule getProbabilisticDecriptionRule() {
		return getProbabilisticDecriptionAccess().getRule();
	}
	
	//Swarmconf:
	//	'The' 'robot' 'swarm' 'consists' 'of' x=Range r=Robot pr=ProbabilisticDecription
	//	//('distributed' 'in' dis=Distribution 'way' 'in' k=Region )*
	//;
	public SwarmconfElements getSwarmconfAccess() {
		return pSwarmconf;
	}
	
	public ParserRule getSwarmconfRule() {
		return getSwarmconfAccess().getRule();
	}
	
	//MissionTime:
	//	'The' 'total' 'time' 'of' 'the' 'mission' 'is' T=Range;
	public MissionTimeElements getMissionTimeAccess() {
		return pMissionTime;
	}
	
	public ParserRule getMissionTimeRule() {
		return getMissionTimeAccess().getRule();
	}
	
	//Mission:
	//	'The' 'mission' 'of' 'the' 'robots' 'is' 'to' t=Task m=Metric;
	public MissionElements getMissionAccess() {
		return pMission;
	}
	
	public ParserRule getMissionRule() {
		return getMissionAccess().getRule();
	}
	
	//Task:
	//	'aggregate' 'on' r=Region;
	public TaskElements getTaskAccess() {
		return pTask;
	}
	
	public ParserRule getTaskRule() {
		return getTaskAccess().getRule();
	}
	
	//Metric:
	//	'seconds' | 'steps';
	public MetricElements getMetricAccess() {
		return pMetric;
	}
	
	public ParserRule getMetricRule() {
		return getMetricAccess().getRule();
	}
	
	//MissionObjective:
	//	'The' 'performance' 'measure' 'is' 'defined' 'in' 'terms' 'of' 'an' 'objective' 'function' 'that' 'maximizes' 'the'
	//	'following' 'score' ':' in+=Indicator*;
	public MissionObjectiveElements getMissionObjectiveAccess() {
		return pMissionObjective;
	}
	
	public ParserRule getMissionObjectiveRule() {
		return getMissionObjectiveAccess().getRule();
	}
	
	//Indicator:
	//	sp=Scope oc=(AtomicIndicator | CompoundIndicator);
	public IndicatorElements getIndicatorAccess() {
		return pIndicator;
	}
	
	public ParserRule getIndicatorRule() {
		return getIndicatorAccess().getRule();
	}
	
	//AtomicIndicator:
	//	'each' 'robot' oc=Occurence;
	public AtomicIndicatorElements getAtomicIndicatorAccess() {
		return pAtomicIndicator;
	}
	
	public ParserRule getAtomicIndicatorRule() {
		return getAtomicIndicatorAccess().getRule();
	}
	
	//CompoundIndicator:
	//	'the' 'swarm' oc=Occurence;
	public CompoundIndicatorElements getCompoundIndicatorAccess() {
		return pCompoundIndicator;
	}
	
	public ParserRule getCompoundIndicatorRule() {
		return getCompoundIndicatorAccess().getRule();
	}
	
	//Scope:
	//	sp=("At any point of time" | "At the end of the mission");
	public ScopeElements getScopeAccess() {
		return pScope;
	}
	
	public ParserRule getScopeRule() {
		return getScopeAccess().getRule();
	}
	
	//AtomicEvent:
	//	'Walls change color';
	public AtomicEventElements getAtomicEventAccess() {
		return pAtomicEvent;
	}
	
	public ParserRule getAtomicEventRule() {
		return getAtomicEventAccess().getRule();
	}
	
	//Occurence:
	//	Reward | Penalty;
	public OccurenceElements getOccurenceAccess() {
		return pOccurence;
	}
	
	public ParserRule getOccurenceRule() {
		return getOccurenceAccess().getRule();
	}
	
	//Penalty:
	//	'gets' 'a' 'penalty' k=Double c=Condition;
	public PenaltyElements getPenaltyAccess() {
		return pPenalty;
	}
	
	public ParserRule getPenaltyRule() {
		return getPenaltyAccess().getRule();
	}
	
	//Reward:
	//	'gets' 'a' 'reward' k=Double c=Condition;
	public RewardElements getRewardAccess() {
		return pReward;
	}
	
	public ParserRule getRewardRule() {
		return getRewardAccess().getRule();
	}
	
	//Condition:
	//	'if' 'it' 'is' 'on' 'the' r=Region |
	//	'if' 'there' 'are' 'more' 'than' n=INT 'robots' 'on' 'the' r=Region;
	public ConditionElements getConditionAccess() {
		return pCondition;
	}
	
	public ParserRule getConditionRule() {
		return getConditionAccess().getRule();
	}
	
	//Time:
	//	x=Literal | 'beggining' 'of' 'the' 'mission' | 'end' 'of' 'the' 'mission';
	public TimeElements getTimeAccess() {
		return pTime;
	}
	
	public ParserRule getTimeRule() {
		return getTimeAccess().getRule();
	}
	
	//Robot:
	//	'e-puck' | 'foot-boot';
	public RobotElements getRobotAccess() {
		return pRobot;
	}
	
	public ParserRule getRobotRule() {
		return getRobotAccess().getRule();
	}
	
	//Distribution:
	//	'uniform' | 'gaussian' | 'constant';
	public DistributionElements getDistributionAccess() {
		return pDistribution;
	}
	
	public ParserRule getDistributionRule() {
		return getDistributionAccess().getRule();
	}
	
	//EnvironmentElements:
	//	EnvironmentElement | ElementDescription;
	public EnvironmentElementsElements getEnvironmentElementsAccess() {
		return pEnvironmentElements;
	}
	
	public ParserRule getEnvironmentElementsRule() {
		return getEnvironmentElementsAccess().getRule();
	}
	
	//EnvironmentElement:
	//	Obstacle | Light | Object;
	public EnvironmentElementElements getEnvironmentElementAccess() {
		return pEnvironmentElement;
	}
	
	public ParserRule getEnvironmentElementRule() {
		return getEnvironmentElementAccess().getRule();
	}
	
	//ElementDescription:
	//	el='There' 'are' x=Range obj=Element r=ProbabilisticDecription;
	public ElementDescriptionElements getElementDescriptionAccess() {
		return pElementDescription;
	}
	
	public ParserRule getElementDescriptionRule() {
		return getElementDescriptionAccess().getRule();
	}
	
	//Element:
	//	'objects' | 'obstacles' | 'light' 'sources';
	public ElementElements getElementAccess() {
		return pElement;
	}
	
	public ParserRule getElementRule() {
		return getElementAccess().getRule();
	}
	
	//Object:
	//	obj='An' 'object' 'as' 'a' r=Region;
	public ObjectElements getObjectAccess() {
		return pObject;
	}
	
	public ParserRule getObjectRule() {
		return getObjectAccess().getRule();
	}
	
	//Obstacle:
	//	obs='An' 'obstacle' 'as' 'a' r=Region;
	public ObstacleElements getObstacleAccess() {
		return pObstacle;
	}
	
	public ParserRule getObstacleRule() {
		return getObstacleAccess().getRule();
	}
	
	//Light:
	//	l='A' 'light' 'source' 'emitting' 'a' c=Color 'light' 'is' 'placed' 'in' 'a' p=Position;
	public LightElements getLightAccess() {
		return pLight;
	}
	
	public ParserRule getLightRule() {
		return getLightAccess().getRule();
	}
	
	//Position:
	//	{Circle} 'center' point=Coordinate | {Rectangle} 'reference point' point=Coordinate | {PointD} 'point'
	//	point=Coordinate;
	public PositionElements getPositionAccess() {
		return pPosition;
	}
	
	public ParserRule getPositionRule() {
		return getPositionAccess().getRule();
	}
	
	//Shape:
	//	'Circle' | 'Polygon' | 'Triangle' | 'Rectangle';
	public ShapeElements getShapeAccess() {
		return pShape;
	}
	
	public ParserRule getShapeRule() {
		return getShapeAccess().getRule();
	}
	
	//Arena:
	//	'The' 'arena' 'is' 'a' s=Region;
	public ArenaElements getArenaAccess() {
		return pArena;
	}
	
	public ParserRule getArenaRule() {
		return getArenaAccess().getRule();
	}
	
	////. 'with' dimensions=Dimension;
	//Color:
	//	'red' | 'yellow' | 'green';
	public ColorElements getColorAccess() {
		return pColor;
	}
	
	public ParserRule getColorRule() {
		return getColorAccess().getRule();
	}
	
	////Region:
	//// 'Circle' | 'Polygon';
	//Region:
	//	colors=Color? shape=Shape? name=ID ('with' referencepoint=Position)? ('and' dimensions=Dimension)?;
	public RegionElements getRegionAccess() {
		return pRegion;
	}
	
	public ParserRule getRegionRule() {
		return getRegionAccess().getRule();
	}
	
	////Type: 
	////	CircleD | RectangleD	
	////;
	//Dimension:
	//	CircleD | RectangleD;
	public DimensionElements getDimensionAccess() {
		return pDimension;
	}
	
	public ParserRule getDimensionRule() {
		return getDimensionAccess().getRule();
	}
	
	////{CircleD} 'radius' r=Double | 
	////{RectangleD} 'length' l=Double ',width' w=Double 'and' 'height' h=Double ; //|
	////types=[CircleD | ]
	////{SquareD} 'side' a=Double;
	//CircleD:
	//	'radius' r=Double;
	public CircleDElements getCircleDAccess() {
		return pCircleD;
	}
	
	public ParserRule getCircleDRule() {
		return getCircleDAccess().getRule();
	}
	
	//RectangleD:
	//	'length' l=Double ',width' w=Double 'and' 'height' h=Double;
	public RectangleDElements getRectangleDAccess() {
		return pRectangleD;
	}
	
	public ParserRule getRectangleDRule() {
		return getRectangleDAccess().getRule();
	}
	
	//Coordinate:
	//	x=Double y=Double;
	public CoordinateElements getCoordinateAccess() {
		return pCoordinate;
	}
	
	public ParserRule getCoordinateRule() {
		return getCoordinateAccess().getRule();
	}
	
	//Double:
	//	INT '.' INT;
	public DoubleElements getDoubleAccess() {
		return pDouble;
	}
	
	public ParserRule getDoubleRule() {
		return getDoubleAccess().getRule();
	}
	
	//Range:
	//	Upperbound | Lowerbound | Interval | LowerorEqualbound | UpperorEqualbound | ConstantSize;
	public RangeElements getRangeAccess() {
		return pRange;
	}
	
	public ParserRule getRangeRule() {
		return getRangeAccess().getRule();
	}
	
	//ConstantSize:
	//	n=INT;
	public ConstantSizeElements getConstantSizeAccess() {
		return pConstantSize;
	}
	
	public ParserRule getConstantSizeRule() {
		return getConstantSizeAccess().getRule();
	}
	
	//Lowerbound:
	//	'less' 'than' n=INT;
	public LowerboundElements getLowerboundAccess() {
		return pLowerbound;
	}
	
	public ParserRule getLowerboundRule() {
		return getLowerboundAccess().getRule();
	}
	
	//LowerorEqualbound:
	//	'less' 'or' 'equal' 'than' n=INT;
	public LowerorEqualboundElements getLowerorEqualboundAccess() {
		return pLowerorEqualbound;
	}
	
	public ParserRule getLowerorEqualboundRule() {
		return getLowerorEqualboundAccess().getRule();
	}
	
	//Upperbound:
	//	'more' 'than' n=INT;
	public UpperboundElements getUpperboundAccess() {
		return pUpperbound;
	}
	
	public ParserRule getUpperboundRule() {
		return getUpperboundAccess().getRule();
	}
	
	//UpperorEqualbound:
	//	'more' 'or' 'equal' 'than' n=INT;
	public UpperorEqualboundElements getUpperorEqualboundAccess() {
		return pUpperorEqualbound;
	}
	
	public ParserRule getUpperorEqualboundRule() {
		return getUpperorEqualboundAccess().getRule();
	}
	
	////
	//Interval:
	//	'between' m=INT 'and' n=INT;
	public IntervalElements getIntervalAccess() {
		return pInterval;
	}
	
	public ParserRule getIntervalRule() {
		return getIntervalAccess().getRule();
	}
	
	//Literal ArithmeticExpression:
	//	'IntLiteral' | 'RealLiteral' | BoolLiteral;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	////IntLiteral:
	////value=SignedInt;
	////RealLiteral:
	////value=SignedReal;
	//BoolLiteral:
	//	value=('true' | 'false');
	public BoolLiteralElements getBoolLiteralAccess() {
		return pBoolLiteral;
	}
	
	public ParserRule getBoolLiteralRule() {
		return getBoolLiteralAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
