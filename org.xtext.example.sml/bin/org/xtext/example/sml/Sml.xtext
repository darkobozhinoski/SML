grammar org.xtext.example.sml.Sml with org.eclipse.xtext.common.Terminals
//import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate sml "http://www.xtext.org/example/sml/Sml"

Model:
	arenas=Arena (env=Environment) (sw=Swarmconf)* (ms=MissionSpecification)*;
	
Environment:
	('The' 'arena' 'contains' 'the' 'following' 'elements' ':')? (environment+=EnvironmentElements)*;

	
ProbabilisticDecription:
	 'distributed' 'with' 'a' dis=Distribution 'distribution' 'in' k=[Region] 
;
Swarmconf: 'The' 'robot' 'swarm' 'consists' 'of' x=Range r=Robot pr=ProbabilisticDecription
//('distributed' 'in' dis=Distribution 'way' 'in' k=Region )*
;


MissionSpecification: m=Mission mt=MissionTime ob=MissionObjective ;

MissionTime: 'The' 'total' 'time' 'of' 'the' 'mission' 'is' t=Range m=Metric;
Mission: 'The' 'mission' 'of' 'the' 'robots' 'is' 'to' t=Task;
Task:
    Aggregate | Migration | Foraging 
;

Aggregate:
	'aggregate' 'on' r+=[Region] (',' r+=[Region])*
;

Migration:
	'aggregate' 'on' r+=[Region] (',' r+=[Region])* 'while' 'avoiding' t+=[Region] (',' t+=[Region])*
;

Foraging:
	'collect' 'food' 'from' source+=[Region] (',' source+=[Region])* 'and' 'bring' 'it' 'back' 'to' nest=[Region]  (',' source+=[Region])*
;



Metric:
	'seconds' | 'steps' | 'm'
;


MissionObjective:
	'The' 'performance' 'measure' 'is' 'defined' 'in' 'terms' 'of' 'an' 'objective' 'function' 'to' 'be' Type=('maximized.' | 'minimized.')
	'The' 'objective' 'function' 'is' 'computed' 'as' 'follows:' 	(in+=Indicator)*
//	'The' 'performance' 'measure' 'is' 'defined' 'in' 'terms' 'of' 'an' 'objective' 'function' 'that' 'maximizes' 'the' 'following' 'score' ':' 
;

Indicator:
	sp=Scope  oc= (AtomicIndicator | CompoundIndicator) 
;
AtomicIndicator:
	'each' 'robot' oc=Occurence 
;
CompoundIndicator:
	'the' 'swarm' oc=Occurence 
;
Scope:
	sp =("At any point in time," | "At the end of the mission,") | Condition
		
		//| 'Before' p=AtomicEvent| 'After' p=(AtomicEvent) | 'Between'   p=AtomicEvent 'and' q=AtomicEvent | 'After' p=AtomicEvent 'Untii' q=AtomicEvent | 'at' 'time' t=Time
	
;

AtomicEvent:
	'Walls change color'
;
Occurence:
	Reward | Penalty
;


Penalty:
	'gets' 'a' 'penalty'  k=Double c=Condition
;


Reward:
	'gets' 'a' 'reward' k=Double c=Condition
;


Condition:
	('if' | 'If') 'it' 'is' ('on' | 'outside')  r=[Region] |
	('if' | 'If')'there' 'are' 'more' 'than' n=INT 'robots'('on' | 'outside')   r=[Region] (",")*  |
	('if' | 'If') 'it' 'goes' 'from' r=[Region] 'into' nest=[Region]
;

Time:
	x=Range | 'beggining' 'of' 'the' 'mission' |'end' 'of' 'the' 'mission'
;


Robot:
	'e-puck' | 'foot-boot'
;

Distribution:
	'Uniform' |'Gaussian' | 'Constant'
;
EnvironmentElements:
	EnvironmentElement | ElementDescription
	;

EnvironmentElement:
	Obstacle | Light | Object | Patch  | 'A' Region
;

ElementDescription:
	el='There' 'are'  x=Range obj=Element r=ProbabilisticDecription
;
Element:
	ob=El 'with' 'dimensions' ':' d=Dimension2
;

El:
	'objects' | 'obstacles' | 'light' 'sources' | 'patch'
;
Object:
	obj='An' 'object' 'as' 'a' r=Region
;
Obstacle:
	//shape=Shape*
	//dimensions=Dimension
	//position=Position
	obs='An' 'obstacle' 'as' 'a' r=Region
;

Patch:
	pt='A' c=Color 'patch' 'as' 'a' r=Region
;

Light:
	l='A' 'light' 'source' 'emitting' 'a' c=Color 'light' 'is' 'placed' 'at' p=Position
;

Position:
	('center' 'at' |  'reference')?  'point' point=(Coordinate2D | Coordinate3D) 
;

Shape2D:
	 'Circle' | 'Polygon' | 'Triangle' | 'Rectangle' | 'Dodecagon' | 'Hexagon' | 'Square' | 'Region'
;

Shape3D:
	'Rectangular cuboid' | 'Cube' | 'Cylinder' 
;
	 
Arena:
	'The' 'arena' 'is' 'a' s=Region 'surrounded' 'by' 'walls' '.';
	//. 'with' dimensions=Dimension;

Color:
	'red' | 'yellow' | 'green' |'gray' | 'black' | 'white';

//Region:
	// 'Circle' | 'Polygon';

Region:
	(colors=Color)? (shape2d=Shape2D) (name=ID)  region=RegionDefinition; 

RegionDefinition:
	DefinitionOne | DefinitionTwo | DefinitionThree
;	
	
DefinitionOne:
	('with' referencepoint=Position)? ('and' dimensions=Dimension)?
;

DefinitionTwo:
	'defined' 'through' 'the' 'following' 'Vertices' ':' (point+=Position) (';' point+=Position)*

;	

DefinitionThree:
	'where' ax=Axis 'is' r=Range 
	
	;

Axis:
	'x' | 'y'
;
	
//Type: 
//	CircleD | RectangleD	
//;

Dimension:
	Dimension1 | Dimension2 | Dimension3
;


Dimension1: 
	'radius' r=Double m1=Metric  ('and' 'height' h=Double m2=Metric)?
;
 
Dimension2:
 'length' l=Double m3=Metric ',width' w=Double m4=Metric ('and' 'height' h=Double m5=Metric)?;

 Dimension3:    
  	'side' s=Double m6=Metric
  ;

//Dimension:
	//CircleD | RectangleD | SquareD
//;
	//{CircleD} 'radius' r=Double | 
	//{RectangleD} 'length' l=Double ',width' w=Double 'and' 'height' h=Double ; //|
	//types=[CircleD | ]
	//{SquareD} 'side' a=Double;


//CircleD:
//	'radius' r=Double
//;
//RectangleD:
//	'length' l=Double ',width' w=Double 'and' 'height' h=Double 
//;


// SquareD:
// 	'side' a=Double
// ;

Coordinate2D:
	x=Double ',' y=Double 
;


Coordinate3D:
	x=Double ',' y=Double ',' z=Double
;

Double:
   ('-')? INT ('.' INT)?;
    
Range:
	Upperbound | Lowerbound | Interval | LowerorEqualbound | UpperorEqualbound | ConstantSize;
	

ConstantSize:
	n=Double
;	

Lowerbound:
	'less' 'than' n = Double;

LowerorEqualbound:
	'less' 'or' 'equal' 'than' n = Double;

Upperbound:
	'more' 'than' n = Double;

UpperorEqualbound:
	'more' 'or' 'equal' 'than' n=Double;
//
Interval:
	 n=Double 'to' m=Double;
	
	
//Literal returns ArithmeticExpression:
	//'IntLiteral' | 'RealLiteral'  | BoolLiteral;

//IntLiteral:
	//value=SignedInt;
	
//RealLiteral:
	//value=SignedReal;
	
	
//BoolLiteral:
	//value=('true'|'false');

//SignedInt returns ecore::EInt:
	//'-'? INT;

//SignedReal returns ecore::EBigDecimal:
	//'-'? REAL;
	
//terminal REAL returns ecore::EBigDecimal: INT? '.' INT;
	

//
//Probability:
//	'with' 'a' 'probability' r=Range

