/*
 * generated by Xtext 2.19.0
 */
package org.xtext.example.sml.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.sml.services.SmlGrammarAccess;
import org.xtext.example.sml.sml.Aggregate;
import org.xtext.example.sml.sml.Arena;
import org.xtext.example.sml.sml.AtomicIndicator;
import org.xtext.example.sml.sml.CompoundIndicator;
import org.xtext.example.sml.sml.Condition;
import org.xtext.example.sml.sml.ConstantSize;
import org.xtext.example.sml.sml.Coordinate2D;
import org.xtext.example.sml.sml.Coordinate3D;
import org.xtext.example.sml.sml.DefinitionOne;
import org.xtext.example.sml.sml.DefinitionThree;
import org.xtext.example.sml.sml.DefinitionTwo;
import org.xtext.example.sml.sml.Dimension1;
import org.xtext.example.sml.sml.Dimension2;
import org.xtext.example.sml.sml.Dimension3;
import org.xtext.example.sml.sml.Element;
import org.xtext.example.sml.sml.ElementDescription;
import org.xtext.example.sml.sml.Environment;
import org.xtext.example.sml.sml.Foraging;
import org.xtext.example.sml.sml.Indicator;
import org.xtext.example.sml.sml.Interval;
import org.xtext.example.sml.sml.Light;
import org.xtext.example.sml.sml.Lowerbound;
import org.xtext.example.sml.sml.LowerorEqualbound;
import org.xtext.example.sml.sml.Migration;
import org.xtext.example.sml.sml.Mission;
import org.xtext.example.sml.sml.MissionObjective;
import org.xtext.example.sml.sml.MissionSpecification;
import org.xtext.example.sml.sml.MissionTime;
import org.xtext.example.sml.sml.Model;
import org.xtext.example.sml.sml.Obstacle;
import org.xtext.example.sml.sml.Patch;
import org.xtext.example.sml.sml.Penalty;
import org.xtext.example.sml.sml.Position;
import org.xtext.example.sml.sml.ProbabilisticDecription;
import org.xtext.example.sml.sml.Region;
import org.xtext.example.sml.sml.Reward;
import org.xtext.example.sml.sml.Scope;
import org.xtext.example.sml.sml.SmlPackage;
import org.xtext.example.sml.sml.Swarmconf;
import org.xtext.example.sml.sml.Time;
import org.xtext.example.sml.sml.Upperbound;
import org.xtext.example.sml.sml.UpperorEqualbound;

@SuppressWarnings("all")
public class SmlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SmlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SmlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SmlPackage.AGGREGATE:
				sequence_Aggregate(context, (Aggregate) semanticObject); 
				return; 
			case SmlPackage.ARENA:
				sequence_Arena(context, (Arena) semanticObject); 
				return; 
			case SmlPackage.ATOMIC_INDICATOR:
				sequence_AtomicIndicator(context, (AtomicIndicator) semanticObject); 
				return; 
			case SmlPackage.COMPOUND_INDICATOR:
				sequence_CompoundIndicator(context, (CompoundIndicator) semanticObject); 
				return; 
			case SmlPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case SmlPackage.CONSTANT_SIZE:
				sequence_ConstantSize(context, (ConstantSize) semanticObject); 
				return; 
			case SmlPackage.COORDINATE2_D:
				sequence_Coordinate2D(context, (Coordinate2D) semanticObject); 
				return; 
			case SmlPackage.COORDINATE3_D:
				sequence_Coordinate3D(context, (Coordinate3D) semanticObject); 
				return; 
			case SmlPackage.DEFINITION_ONE:
				sequence_DefinitionOne(context, (DefinitionOne) semanticObject); 
				return; 
			case SmlPackage.DEFINITION_THREE:
				sequence_DefinitionThree(context, (DefinitionThree) semanticObject); 
				return; 
			case SmlPackage.DEFINITION_TWO:
				sequence_DefinitionTwo(context, (DefinitionTwo) semanticObject); 
				return; 
			case SmlPackage.DIMENSION1:
				sequence_Dimension1(context, (Dimension1) semanticObject); 
				return; 
			case SmlPackage.DIMENSION2:
				sequence_Dimension2(context, (Dimension2) semanticObject); 
				return; 
			case SmlPackage.DIMENSION3:
				sequence_Dimension3(context, (Dimension3) semanticObject); 
				return; 
			case SmlPackage.ELEMENT:
				sequence_Element(context, (Element) semanticObject); 
				return; 
			case SmlPackage.ELEMENT_DESCRIPTION:
				sequence_ElementDescription(context, (ElementDescription) semanticObject); 
				return; 
			case SmlPackage.ENVIRONMENT:
				sequence_Environment(context, (Environment) semanticObject); 
				return; 
			case SmlPackage.FORAGING:
				sequence_Foraging(context, (Foraging) semanticObject); 
				return; 
			case SmlPackage.INDICATOR:
				sequence_Indicator(context, (Indicator) semanticObject); 
				return; 
			case SmlPackage.INTERVAL:
				sequence_Interval(context, (Interval) semanticObject); 
				return; 
			case SmlPackage.LIGHT:
				sequence_Light(context, (Light) semanticObject); 
				return; 
			case SmlPackage.LOWERBOUND:
				sequence_Lowerbound(context, (Lowerbound) semanticObject); 
				return; 
			case SmlPackage.LOWEROR_EQUALBOUND:
				sequence_LowerorEqualbound(context, (LowerorEqualbound) semanticObject); 
				return; 
			case SmlPackage.MIGRATION:
				sequence_Migration(context, (Migration) semanticObject); 
				return; 
			case SmlPackage.MISSION:
				sequence_Mission(context, (Mission) semanticObject); 
				return; 
			case SmlPackage.MISSION_OBJECTIVE:
				sequence_MissionObjective(context, (MissionObjective) semanticObject); 
				return; 
			case SmlPackage.MISSION_SPECIFICATION:
				sequence_MissionSpecification(context, (MissionSpecification) semanticObject); 
				return; 
			case SmlPackage.MISSION_TIME:
				sequence_MissionTime(context, (MissionTime) semanticObject); 
				return; 
			case SmlPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SmlPackage.OBJECT:
				sequence_Object(context, (org.xtext.example.sml.sml.Object) semanticObject); 
				return; 
			case SmlPackage.OBSTACLE:
				sequence_Obstacle(context, (Obstacle) semanticObject); 
				return; 
			case SmlPackage.PATCH:
				sequence_Patch(context, (Patch) semanticObject); 
				return; 
			case SmlPackage.PENALTY:
				sequence_Penalty(context, (Penalty) semanticObject); 
				return; 
			case SmlPackage.POSITION:
				sequence_Position(context, (Position) semanticObject); 
				return; 
			case SmlPackage.PROBABILISTIC_DECRIPTION:
				sequence_ProbabilisticDecription(context, (ProbabilisticDecription) semanticObject); 
				return; 
			case SmlPackage.REGION:
				sequence_Region(context, (Region) semanticObject); 
				return; 
			case SmlPackage.REWARD:
				sequence_Reward(context, (Reward) semanticObject); 
				return; 
			case SmlPackage.SCOPE:
				sequence_Scope(context, (Scope) semanticObject); 
				return; 
			case SmlPackage.SWARMCONF:
				sequence_Swarmconf(context, (Swarmconf) semanticObject); 
				return; 
			case SmlPackage.TIME:
				sequence_Time(context, (Time) semanticObject); 
				return; 
			case SmlPackage.UPPERBOUND:
				sequence_Upperbound(context, (Upperbound) semanticObject); 
				return; 
			case SmlPackage.UPPEROR_EQUALBOUND:
				sequence_UpperorEqualbound(context, (UpperorEqualbound) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Task returns Aggregate
	 *     Aggregate returns Aggregate
	 *
	 * Constraint:
	 *     (r+=[Region|ID] r+=[Region|ID]*)
	 */
	protected void sequence_Aggregate(ISerializationContext context, Aggregate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Arena returns Arena
	 *
	 * Constraint:
	 *     s=Region
	 */
	protected void sequence_Arena(ISerializationContext context, Arena semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.ARENA__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.ARENA__S));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArenaAccess().getSRegionParserRuleCall_4_0(), semanticObject.getS());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AtomicIndicator returns AtomicIndicator
	 *
	 * Constraint:
	 *     oc=Occurence
	 */
	protected void sequence_AtomicIndicator(ISerializationContext context, AtomicIndicator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.ATOMIC_INDICATOR__OC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.ATOMIC_INDICATOR__OC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicIndicatorAccess().getOcOccurenceParserRuleCall_2_0(), semanticObject.getOc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompoundIndicator returns CompoundIndicator
	 *
	 * Constraint:
	 *     oc=Occurence
	 */
	protected void sequence_CompoundIndicator(ISerializationContext context, CompoundIndicator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.COMPOUND_INDICATOR__OC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.COMPOUND_INDICATOR__OC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompoundIndicatorAccess().getOcOccurenceParserRuleCall_2_0(), semanticObject.getOc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Condition
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (r=[Region|ID] | (n=INT r=[Region|ID]) | (r=[Region|ID] nest=[Region|ID]))
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Range returns ConstantSize
	 *     ConstantSize returns ConstantSize
	 *
	 * Constraint:
	 *     n=Double
	 */
	protected void sequence_ConstantSize(ISerializationContext context, ConstantSize semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.RANGE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.RANGE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantSizeAccess().getNDoubleParserRuleCall_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Coordinate2D returns Coordinate2D
	 *
	 * Constraint:
	 *     (x=Double y=Double)
	 */
	protected void sequence_Coordinate2D(ISerializationContext context, Coordinate2D semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.COORDINATE2_D__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.COORDINATE2_D__X));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.COORDINATE2_D__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.COORDINATE2_D__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCoordinate2DAccess().getXDoubleParserRuleCall_0_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getCoordinate2DAccess().getYDoubleParserRuleCall_2_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Coordinate3D returns Coordinate3D
	 *
	 * Constraint:
	 *     (x=Double y=Double z=Double)
	 */
	protected void sequence_Coordinate3D(ISerializationContext context, Coordinate3D semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.COORDINATE3_D__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.COORDINATE3_D__X));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.COORDINATE3_D__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.COORDINATE3_D__Y));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.COORDINATE3_D__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.COORDINATE3_D__Z));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCoordinate3DAccess().getXDoubleParserRuleCall_0_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getCoordinate3DAccess().getYDoubleParserRuleCall_2_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getCoordinate3DAccess().getZDoubleParserRuleCall_4_0(), semanticObject.getZ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RegionDefinition returns DefinitionOne
	 *     DefinitionOne returns DefinitionOne
	 *
	 * Constraint:
	 *     ((referencepoint=Position dimensions=Dimension) | dimensions=Dimension)?
	 */
	protected void sequence_DefinitionOne(ISerializationContext context, DefinitionOne semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegionDefinition returns DefinitionThree
	 *     DefinitionThree returns DefinitionThree
	 *
	 * Constraint:
	 *     (ax=Axis r=Range)
	 */
	protected void sequence_DefinitionThree(ISerializationContext context, DefinitionThree semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.DEFINITION_THREE__AX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.DEFINITION_THREE__AX));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.DEFINITION_THREE__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.DEFINITION_THREE__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefinitionThreeAccess().getAxAxisParserRuleCall_1_0(), semanticObject.getAx());
		feeder.accept(grammarAccess.getDefinitionThreeAccess().getRRangeParserRuleCall_3_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RegionDefinition returns DefinitionTwo
	 *     DefinitionTwo returns DefinitionTwo
	 *
	 * Constraint:
	 *     (point+=Position point+=Position*)
	 */
	protected void sequence_DefinitionTwo(ISerializationContext context, DefinitionTwo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Dimension returns Dimension1
	 *     Dimension1 returns Dimension1
	 *
	 * Constraint:
	 *     (r=Double m1=Metric (h=Double m2=Metric)?)
	 */
	protected void sequence_Dimension1(ISerializationContext context, Dimension1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Dimension returns Dimension2
	 *     Dimension2 returns Dimension2
	 *
	 * Constraint:
	 *     (l=Double m3=Metric w=Double m4=Metric (h=Double m5=Metric)?)
	 */
	protected void sequence_Dimension2(ISerializationContext context, Dimension2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Dimension returns Dimension3
	 *     Dimension3 returns Dimension3
	 *
	 * Constraint:
	 *     (s=Double m6=Metric)
	 */
	protected void sequence_Dimension3(ISerializationContext context, Dimension3 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.DIMENSION3__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.DIMENSION3__S));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.DIMENSION3__M6) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.DIMENSION3__M6));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDimension3Access().getSDoubleParserRuleCall_1_0(), semanticObject.getS());
		feeder.accept(grammarAccess.getDimension3Access().getM6MetricParserRuleCall_2_0(), semanticObject.getM6());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentElements returns ElementDescription
	 *     ElementDescription returns ElementDescription
	 *
	 * Constraint:
	 *     (x=Range obj=Element r=ProbabilisticDecription)
	 */
	protected void sequence_ElementDescription(ISerializationContext context, ElementDescription semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.ELEMENT_DESCRIPTION__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.ELEMENT_DESCRIPTION__X));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.ELEMENT_DESCRIPTION__OBJ) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.ELEMENT_DESCRIPTION__OBJ));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.ELEMENT_DESCRIPTION__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.ELEMENT_DESCRIPTION__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementDescriptionAccess().getXRangeParserRuleCall_2_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getElementDescriptionAccess().getObjElementParserRuleCall_3_0(), semanticObject.getObj());
		feeder.accept(grammarAccess.getElementDescriptionAccess().getRProbabilisticDecriptionParserRuleCall_4_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Element
	 *
	 * Constraint:
	 *     (ob=El d=Dimension2? (w=Double sm=Metric)? it=Double?)
	 */
	protected void sequence_Element(ISerializationContext context, Element semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Environment returns Environment
	 *
	 * Constraint:
	 *     environment+=EnvironmentElements+
	 */
	protected void sequence_Environment(ISerializationContext context, Environment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Task returns Foraging
	 *     Foraging returns Foraging
	 *
	 * Constraint:
	 *     (source+=[Region|ID] source+=[Region|ID]* nest=[Region|ID] source+=[Region|ID]*)
	 */
	protected void sequence_Foraging(ISerializationContext context, Foraging semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Indicator returns Indicator
	 *
	 * Constraint:
	 *     (sp=Scope (oc=AtomicIndicator | oc=CompoundIndicator))
	 */
	protected void sequence_Indicator(ISerializationContext context, Indicator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Range returns Interval
	 *     Interval returns Interval
	 *
	 * Constraint:
	 *     ((n=Double m=Double) | (n=Double m=Double))
	 */
	protected void sequence_Interval(ISerializationContext context, Interval semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentElements returns Light
	 *     EnvironmentElement returns Light
	 *     Light returns Light
	 *
	 * Constraint:
	 *     (l='A' c=Color it=Double p=Position)
	 */
	protected void sequence_Light(ISerializationContext context, Light semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.LIGHT__L) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.LIGHT__L));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.LIGHT__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.LIGHT__C));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.LIGHT__IT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.LIGHT__IT));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.LIGHT__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.LIGHT__P));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLightAccess().getLAKeyword_0_0(), semanticObject.getL());
		feeder.accept(grammarAccess.getLightAccess().getCColorParserRuleCall_5_0(), semanticObject.getC());
		feeder.accept(grammarAccess.getLightAccess().getItDoubleParserRuleCall_9_0(), semanticObject.getIt());
		feeder.accept(grammarAccess.getLightAccess().getPPositionParserRuleCall_13_0(), semanticObject.getP());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Range returns Lowerbound
	 *     Lowerbound returns Lowerbound
	 *
	 * Constraint:
	 *     n=Double
	 */
	protected void sequence_Lowerbound(ISerializationContext context, Lowerbound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.RANGE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.RANGE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLowerboundAccess().getNDoubleParserRuleCall_2_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Range returns LowerorEqualbound
	 *     LowerorEqualbound returns LowerorEqualbound
	 *
	 * Constraint:
	 *     n=Double
	 */
	protected void sequence_LowerorEqualbound(ISerializationContext context, LowerorEqualbound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.RANGE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.RANGE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLowerorEqualboundAccess().getNDoubleParserRuleCall_4_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Task returns Migration
	 *     Migration returns Migration
	 *
	 * Constraint:
	 *     (r+=[Region|ID] r+=[Region|ID]* t+=[Region|ID] t+=[Region|ID]*)
	 */
	protected void sequence_Migration(ISerializationContext context, Migration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MissionObjective returns MissionObjective
	 *
	 * Constraint:
	 *     ((Type='maximized.' | Type='minimized.') in+=Indicator*)
	 */
	protected void sequence_MissionObjective(ISerializationContext context, MissionObjective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MissionSpecification returns MissionSpecification
	 *
	 * Constraint:
	 *     (m=Mission mt=MissionTime ob=MissionObjective)
	 */
	protected void sequence_MissionSpecification(ISerializationContext context, MissionSpecification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.MISSION_SPECIFICATION__M) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.MISSION_SPECIFICATION__M));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.MISSION_SPECIFICATION__MT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.MISSION_SPECIFICATION__MT));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.MISSION_SPECIFICATION__OB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.MISSION_SPECIFICATION__OB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMissionSpecificationAccess().getMMissionParserRuleCall_0_0(), semanticObject.getM());
		feeder.accept(grammarAccess.getMissionSpecificationAccess().getMtMissionTimeParserRuleCall_1_0(), semanticObject.getMt());
		feeder.accept(grammarAccess.getMissionSpecificationAccess().getObMissionObjectiveParserRuleCall_2_0(), semanticObject.getOb());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MissionTime returns MissionTime
	 *
	 * Constraint:
	 *     (t=Range m=Metric)
	 */
	protected void sequence_MissionTime(ISerializationContext context, MissionTime semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.MISSION_TIME__T) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.MISSION_TIME__T));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.MISSION_TIME__M) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.MISSION_TIME__M));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMissionTimeAccess().getTRangeParserRuleCall_7_0(), semanticObject.getT());
		feeder.accept(grammarAccess.getMissionTimeAccess().getMMetricParserRuleCall_8_0(), semanticObject.getM());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Mission returns Mission
	 *
	 * Constraint:
	 *     t=Task
	 */
	protected void sequence_Mission(ISerializationContext context, Mission semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.MISSION__T) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.MISSION__T));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMissionAccess().getTTaskParserRuleCall_7_0(), semanticObject.getT());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (arenas=Arena env=Environment sw=Swarmconf* ms=MissionSpecification*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentElements returns Object
	 *     EnvironmentElement returns Object
	 *     Object returns Object
	 *
	 * Constraint:
	 *     (obj='An' r=Region)
	 */
	protected void sequence_Object(ISerializationContext context, org.xtext.example.sml.sml.Object semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OBJECT__OBJ) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OBJECT__OBJ));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OBJECT__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OBJECT__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectAccess().getObjAnKeyword_0_0(), semanticObject.getObj());
		feeder.accept(grammarAccess.getObjectAccess().getRRegionParserRuleCall_4_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentElements returns Obstacle
	 *     EnvironmentElement returns Obstacle
	 *     Obstacle returns Obstacle
	 *
	 * Constraint:
	 *     (obs='An' r=Region)
	 */
	protected void sequence_Obstacle(ISerializationContext context, Obstacle semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OBSTACLE__OBS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OBSTACLE__OBS));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OBSTACLE__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OBSTACLE__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObstacleAccess().getObsAnKeyword_0_0(), semanticObject.getObs());
		feeder.accept(grammarAccess.getObstacleAccess().getRRegionParserRuleCall_4_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentElements returns Patch
	 *     EnvironmentElement returns Patch
	 *     Patch returns Patch
	 *
	 * Constraint:
	 *     (c=Color r=Region)
	 */
	protected void sequence_Patch(ISerializationContext context, Patch semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.PATCH__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.PATCH__C));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.PATCH__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.PATCH__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatchAccess().getCColorParserRuleCall_1_0(), semanticObject.getC());
		feeder.accept(grammarAccess.getPatchAccess().getRRegionParserRuleCall_5_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Occurence returns Penalty
	 *     Penalty returns Penalty
	 *
	 * Constraint:
	 *     (k=Double c=Condition)
	 */
	protected void sequence_Penalty(ISerializationContext context, Penalty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OCCURENCE__K) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OCCURENCE__K));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OCCURENCE__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OCCURENCE__C));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPenaltyAccess().getKDoubleParserRuleCall_3_0(), semanticObject.getK());
		feeder.accept(grammarAccess.getPenaltyAccess().getCConditionParserRuleCall_4_0(), semanticObject.getC());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Position returns Position
	 *
	 * Constraint:
	 *     (point=Coordinate2D | point=Coordinate3D)
	 */
	protected void sequence_Position(ISerializationContext context, Position semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProbabilisticDecription returns ProbabilisticDecription
	 *
	 * Constraint:
	 *     (dis=Distribution k=[Region|ID])
	 */
	protected void sequence_ProbabilisticDecription(ISerializationContext context, ProbabilisticDecription semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.PROBABILISTIC_DECRIPTION__DIS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.PROBABILISTIC_DECRIPTION__DIS));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.PROBABILISTIC_DECRIPTION__K) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.PROBABILISTIC_DECRIPTION__K));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProbabilisticDecriptionAccess().getDisDistributionParserRuleCall_3_0(), semanticObject.getDis());
		feeder.accept(grammarAccess.getProbabilisticDecriptionAccess().getKRegionIDTerminalRuleCall_6_0_1(), semanticObject.eGet(SmlPackage.Literals.PROBABILISTIC_DECRIPTION__K, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentElements returns Region
	 *     EnvironmentElement returns Region
	 *     Region returns Region
	 *
	 * Constraint:
	 *     (colors=Color? shape2d=Shape2D name=ID region=RegionDefinition)
	 */
	protected void sequence_Region(ISerializationContext context, Region semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Occurence returns Reward
	 *     Reward returns Reward
	 *
	 * Constraint:
	 *     (k=Double c=Condition)
	 */
	protected void sequence_Reward(ISerializationContext context, Reward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OCCURENCE__K) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OCCURENCE__K));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OCCURENCE__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OCCURENCE__C));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRewardAccess().getKDoubleParserRuleCall_3_0(), semanticObject.getK());
		feeder.accept(grammarAccess.getRewardAccess().getCConditionParserRuleCall_4_0(), semanticObject.getC());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Scope
	 *
	 * Constraint:
	 *     (sp='At any point in time,' | sp='At the end of the mission,')
	 */
	protected void sequence_Scope(ISerializationContext context, Scope semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Swarmconf returns Swarmconf
	 *
	 * Constraint:
	 *     (x=Range r=Robot pr=ProbabilisticDecription)
	 */
	protected void sequence_Swarmconf(ISerializationContext context, Swarmconf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.SWARMCONF__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.SWARMCONF__X));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.SWARMCONF__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.SWARMCONF__R));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.SWARMCONF__PR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.SWARMCONF__PR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwarmconfAccess().getXRangeParserRuleCall_5_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getSwarmconfAccess().getRRobotParserRuleCall_6_0(), semanticObject.getR());
		feeder.accept(grammarAccess.getSwarmconfAccess().getPrProbabilisticDecriptionParserRuleCall_7_0(), semanticObject.getPr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Time returns Time
	 *
	 * Constraint:
	 *     x=Range
	 */
	protected void sequence_Time(ISerializationContext context, Time semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.TIME__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.TIME__X));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeAccess().getXRangeParserRuleCall_0_0(), semanticObject.getX());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Range returns Upperbound
	 *     Upperbound returns Upperbound
	 *
	 * Constraint:
	 *     n=Double
	 */
	protected void sequence_Upperbound(ISerializationContext context, Upperbound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.RANGE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.RANGE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpperboundAccess().getNDoubleParserRuleCall_2_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Range returns UpperorEqualbound
	 *     UpperorEqualbound returns UpperorEqualbound
	 *
	 * Constraint:
	 *     n=Double
	 */
	protected void sequence_UpperorEqualbound(ISerializationContext context, UpperorEqualbound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.RANGE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.RANGE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpperorEqualboundAccess().getNDoubleParserRuleCall_4_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
}
