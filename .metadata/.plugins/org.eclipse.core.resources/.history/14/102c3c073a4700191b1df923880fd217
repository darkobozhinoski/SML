grammar org.xtext.example.sml.Sml with org.eclipse.xtext.common.Terminals
//import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate sml "http://www.xtext.org/example/sml/Sml"

Model:
	arenas=Arena env=Environment sw=Swarmconf ob=MissionObjective;
	
Environment:
	('The' 'arena' 'contains' 'the' 'following' 'elements' ':')? (environment+=EnvironmentElements)*;

	
ProbabilisticDecription:
	 'distributed' 'with' 'a' dis=Distribution 'distribution' 'in' 'a' k=Region
	
;
Swarmconf: 'The' 'robot' 'swarm' 'consists' 'of' x=Range r=Robot pr=ProbabilisticDecription
//('distributed' 'in' dis=Distribution 'way' 'in' k=Region )*
;

MissionTime: 'The' 'total' 'time' 'of' 'the' 'mission' 'is' T=Range;
Mission: 'The' 'mission' 'of' 'the' 'robots' 'is' 'to' t=Task m=Metric;
Task:
	'aggregate' 'on' r=Region
;

Metric:
	'seconds' | 'steps'
;
MissionObjective:
	'The' 'performance' 'measure' 'is' 'defined' 'in' 'terms' 'of' 'an' 'objective' 'function' 'that' 'maximizes' 'the' 'following' 'score' ':' in+=Indicator+
;

Indicator:
	sp=Scope  oc= (AtomicIndicator | CompoundIndicator) 
;
AtomicIndicator:
	'each' 'robot' oc=Occurence v=Literal
;
CompoundIndicator:
	'the' 'swarm' oc=Occurence v=Literal
;
Scope:
	'At any point of time' | 'Before' p=AtomicEvent| 'After' p=AtomicEvent | 'Between'   p=AtomicEvent 'and' q=AtomicEvent | 'After' p=AtomicEvent 'Untii' q=AtomicEvent | 'at' 'time' t=Time 
;

AtomicEvent:
	'Walls change color'
;
Occurence:
	Reward | Penatly
;


Penatly:
	'gets' 'a' 'penalty'  k=Double c=Condition
;


Reward:
	'gets' 'a' 'reward' k=Double c=Condition
;


Condition:
	'if' 'it' 'is' 'on' 'the' r=Region |
	'if' 'there' 'are' 'more' 'than' n=INT 'robots' 'on' 'the'  r=Region 
;

Time:
	x=Literal | 'beggining' 'of' 'the' 'mission' |'end' 'of' 'the' 'mission'
;


Robot:
	'e-puck' | 'foot-boot'
;

Distribution:
	'uniform' |'gaussian' | 'constant'
;
EnvironmentElements:
	EnvironmentElement | ElementDescription
	;

EnvironmentElement:
	Obstacle | Light | Object
;

ElementDescription:
	el='There' 'are'  x=Range obj=Element r=ProbabilisticDecription
;
Element:
	'objects' | 'obstacles' | 'light' 'sources'
;

Object:
	obj='An' 'object' 'as' 'a' r=Region
;
Obstacle:
	//shape=Shape*
	//dimensions=Dimension
	//position=Position
	obs='An' 'obstacle' 'as' 'a' r=Region
;


Light:
	l='A' 'light' 'source' 'emitting' 'a' c=Color 'light' 'is' 'placed' 'in' 'a' p=Position
;

Position:
	{Circle} 'center' point=Coordinate |
	{Rectangle} 'reference point' point=Coordinate |
	{PointD} 'point' point=Coordinate 
;

Shape:
	 'Circle' | 'Polygon' | 'Triangle' | 'Rectangle'
;
	 
Arena:
	'The' 'arena' 'is' 'a' s=Region;
	//. 'with' dimensions=Dimension;

Color:
	'red' | 'yellow' | 'green';

//Region:
	// 'Circle' | 'Polygon';

Region:
	(colors=Color)? (shape=Shape)? (name=ID)  ('with' referencepoint=Position)? ('and' dimensions=Dimension)?;
	
//Type: 
//	CircleD | RectangleD	
//;

Dimension:
	CircleD | RectangleD	
;
	//{CircleD} 'radius' r=Double | 
	//{RectangleD} 'length' l=Double ',width' w=Double 'and' 'height' h=Double ; //|
	//types=[CircleD | ]
	//{SquareD} 'side' a=Double;


CircleD:
	'radius' r=Double
;
RectangleD:
	'length' l=Double ',width' w=Double 'and' 'height' h=Double 
;
Coordinate:
	x=Double y=Double
;

Double:
    INT '.' INT;
    
Range:
	Upperbound | Lowerbound | Interval | LowerorEqualbound | UpperorEqualbound | ConstantSize;
	

ConstantSize:
	n=INT
;	

Lowerbound:
	'less' 'than' n = INT;

LowerorEqualbound:
	'less' 'or' 'equal' 'than' n = INT;

Upperbound:
	'more' 'than' n = INT;

UpperorEqualbound:
	'more' 'or' 'equal' 'than' n=INT;
//
Interval:
	'between' m=INT 'and' n=INT;
	
	
Literal returns ArithmeticExpression:
	'IntLiteral' | 'RealLiteral'  | BoolLiteral;

//IntLiteral:
	//value=SignedInt;
	
//RealLiteral:
	//value=SignedReal;
	
	
BoolLiteral:
	value=('true'|'false');

//SignedInt returns ecore::EInt:
	//'-'? INT;

//SignedReal returns ecore::EBigDecimal:
	//'-'? REAL;
	
//terminal REAL returns ecore::EBigDecimal: INT? '.' INT;
	

//
//Probability:
//	'with' 'a' 'probability' r=Range

