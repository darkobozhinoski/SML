grammar org.xtext.example.sml.Sml with org.eclipse.xtext.common.Terminals
generate sml "http://www.xtext.org/example/sml/Sml"
Model:
(env=Environment) (sw=Swarmconf)* (ms=MissionSpecification)*;
Swarmconf: 'The' 'robot' 'swarm' 'consists' 'of' x=Range r=Robot pr=ProbabilisticDecription;
MissionSpecification: m=MissionDefinition mt=MissionTime ob=MissionObjective ;
MissionTime: 'The' 'total' 'time' 'of' 'the' 'mission' 'is' t=Range m=Metric;
MissionDefinition: 'The' 'mission' 'of' 'the' 'robots' 'is' 'to' t=MissionClass;
MissionClass:
    Aggregate | Migration | Foraging;
Aggregate:
'aggregate' 'on' r+=[Region] (',' r+=[Region])*;
Migration:
'aggregate' 'on' r+=[Region] (',' r+=[Region])* 'while' 'avoiding' t+=[Region] (',' t+=[Region])*;
Foraging:
'collect' 'food' 'from' source+=[Region] (',' source+=[Region])* 'and' 'bring' 'it' 'back' 'to' nest=[Region]  (',' source+=[Region])*;
Metric:
'seconds' | 'steps' | 'm' | 'kg';
Environment:
a=Arena ('The' 'arena' 'contains' 'the' 'following' 'elements' ':')? (environment+=EnvironmentElements)*;
ProbabilisticDecription:
'distributed' 'with' 'a' dis=Distribution 'distribution' 'in'  k=[Region];

MissionObjective:
'The' 'performance' 'measure' 'is' 'defined' 'in' 'terms' 'of' 'an' 'objective' 'function' 'to' 'be' Type=('maximized.' | 'minimized.')
'The' 'objective' 'function' 'is' 'computed' 'as' 'follows:' (in+=Indicator)*
// 'The' 'performance' 'measure' 'is' 'defined' 'in' 'terms' 'of' 'an' 'objective' 'function' 'that' 'maximizes' 'the' 'following' 'score' ':'
;

Indicator:
sp=Scope  oc= (AtomicIndicator | CompoundIndicator)
;
AtomicIndicator:
'each' 'robot' oc=Pattern
;
CompoundIndicator:
'the' 'swarm' oc=Pattern
;
Scope:
sp = AnyTimePoint | EndMission | Condition;

//| 'Before' p=AtomicEvent| 'After' p=(AtomicEvent) | 'Between'   p=AtomicEvent 'and' q=AtomicEvent | 'After' p=AtomicEvent 'Untii' q=AtomicEvent | 'at' 'time' t=Time




AtomicEvent:
'walls change color' | 'robot' 'at' r=[Region] | 'Collision'
;
Pattern:
Reward | Penalty
;


Penalty:
'gets' 'a' 'penalty'  k=Double c=Condition
;


Reward:
'gets' 'a' 'reward' k=Double c=Condition
;


Condition returns String:
{existence_absence1}('if' | 'If') 'it' 'is' inside=('on' | 'outside')  r=[Region] |
{existence_absence2} ('if' | 'If')'there' 'are' 'more' 'than' n=INT 'robots' inside=('on' | 'outside')   r=[Region] (",")*  |
{transition} ('if' | 'If') 'it' 'goes' 'from' r=[Region] 'into' nest=[Region] |
{universality} 'always'
;

Time:
x=Range | StartMission | EndMission
;

StartMission: ('Beginning'|'beginning') 'of' 'the' 'mission' (',')*;
EndMission: ('at'|'At') 'the' 'end' 'of' 'the' 'mission' (',')*;
AnyTimePoint: ('at'|'At') 'any' 'point' 'in' 'time' (',')*;


Robot:
'e-puck' | 'foot-boot'
;

Distribution:
'Uniform' |'Gaussian' | 'Constant'
;
EnvironmentElements:
(EnvironmentElement) | (ElementDescription)
;

EnvironmentElement:
Obstacle | Light | Object | Patch  | 'A' Region
;

ElementDescription:
'There' 'are'  x=Range obj=Element r=ProbabilisticDecription
;
Element:
ob=El ('with' 'dimensions' ':' d=Dimension2)? ('and' 'weight' w=Double sm=Metric)? ('with' 'intensity' ':' it=Double)?
;

El:
'objects' | 'obstacles' | 'light' 'sources' | 'patch'
;
Object:
obj='An' 'object' 'as' 'a' r=Region
;
Obstacle:
//shape=Shape*
//dimensions=Dimension
//position=Position
obs='An' 'obstacle' 'as' 'a' r=Region
;

Box:
//shape=Shape*
//dimensions=Dimension
//position=Position
obs='A' 'box' 'as' 'a' r=Region
;

Patch:
   'A' c=Color 'patch' 'as' 'a' r=Region
;

Light:
l='A' 'light' 'source' 'emitting' 'a' c=Color 'light' 'with' 'intensity' it=Double 'is' 'placed' 'at' p=Position
;

Position:
('center' 'at' |  'reference')?  'point' point=(Coordinate2D | Coordinate3D)
;

Shape2D:
'Circle' | 'Polygon' | 'Triangle' | 'Rectangle' | 'Dodecagon' | 'Hexagon' | 'Square' | 'Region'
;

Shape3D:
'Rectangular cuboid' | 'Cube' | 'Cylinder'
;

Arena:
'The' 'arena' 'is' 'a' s=Region 'surrounded' 'by' 'walls' '.';
//. 'with' dimensions=Dimension;

Color:
'red' | 'yellow' | 'green' |'gray' | 'black' | 'white';

//Region:
// 'Circle' | 'Polygon';

Region:
(colors=Color)? (shape2d=Shape2D) (name=ID)  region=RegionDefinition;

RegionDefinition:
Definition1 | Definition2 | Definition3
;

Definition1:
('with' referencepoint=Position)? ('and' dimensions=Dimension)?
;

Definition2:
'defined' 'through' 'the' 'following' 'Vertices' ':' (point+=Position) (';' point+=Position)*

;

Definition3:
'where' ax=Axis 'is' r=Range

;

Axis:
'x' | 'y'
;

//Type:
// CircleD | RectangleD
//;

Dimension:
Dimension1 | Dimension2 | Dimension3
;


Dimension1:
'radius' r=Double m1=Metric  (',' 'height' h=Double m2=Metric)?
;
 
Dimension2:
 'length' l=Double m3=Metric ',width' w=Double m4=Metric (',' 'height' h=Double m5=Metric)?
 ;

 Dimension3:    
  'side' s=Double m6=Metric
  ;

//Dimension:
//CircleD | RectangleD | SquareD
//;
//{CircleD} 'radius' r=Double |
//{RectangleD} 'length' l=Double ',width' w=Double 'and' 'height' h=Double ; //|
//types=[CircleD | ]
//{SquareD} 'side' a=Double;


//CircleD:
// 'radius' r=Double
//;
//RectangleD:
// 'length' l=Double ',width' w=Double 'and' 'height' h=Double
//;


// SquareD:
// 'side' a=Double
// ;

Coordinate2D:
x=Double ',' y=Double
;


Coordinate3D:
x=Double ',' y=Double ',' z=Double
;

Double:
   ('-')? INT ('.' INT)?;
   
Range:
Upperbound | Lowerbound | Interval | LowerorEqualbound | UpperorEqualbound | ConstantSize;


ConstantSize:
n=Double
;

Lowerbound:
'less' 'than' n = Double;

LowerorEqualbound:
'less' 'or' 'equal' 'than' n = Double;

Upperbound:
'more' 'than' n = Double;

UpperorEqualbound:
'more' 'or' 'equal' 'than' n=Double;
//
Interval:
(n=Double 'to' m=Double) | ('between' n=Double 'and' m=Double);


//Literal returns ArithmeticExpression:
//'IntLiteral' | 'RealLiteral'  | BoolLiteral;

//IntLiteral:
//value=SignedInt;

//RealLiteral:
//value=SignedReal;


//BoolLiteral:
//value=('true'|'false');

//SignedInt returns ecore::EInt:
//'-'? INT;

//SignedReal returns ecore::EBigDecimal:
//'-'? REAL;

//terminal REAL returns ecore::EBigDecimal: INT? '.' INT;


//
//Probability:
// 'with' 'a' 'probability' r=Range




