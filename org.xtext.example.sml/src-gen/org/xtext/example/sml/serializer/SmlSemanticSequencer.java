/*
 * generated by Xtext 2.16.0
 */
package org.xtext.example.sml.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.sml.services.SmlGrammarAccess;
import org.xtext.example.sml.sml.Arena;
import org.xtext.example.sml.sml.AtomicIndicator;
import org.xtext.example.sml.sml.BoolLiteral;
import org.xtext.example.sml.sml.Circle;
import org.xtext.example.sml.sml.CircleD;
import org.xtext.example.sml.sml.CompoundIndicator;
import org.xtext.example.sml.sml.Condition;
import org.xtext.example.sml.sml.ConstantSize;
import org.xtext.example.sml.sml.Coordinate;
import org.xtext.example.sml.sml.ElementDescription;
import org.xtext.example.sml.sml.Environment;
import org.xtext.example.sml.sml.Indicator;
import org.xtext.example.sml.sml.Interval;
import org.xtext.example.sml.sml.Light;
import org.xtext.example.sml.sml.Lowerbound;
import org.xtext.example.sml.sml.LowerorEqualbound;
import org.xtext.example.sml.sml.Mission;
import org.xtext.example.sml.sml.MissionObjective;
import org.xtext.example.sml.sml.MissionTime;
import org.xtext.example.sml.sml.Model;
import org.xtext.example.sml.sml.Obstacle;
import org.xtext.example.sml.sml.Penalty;
import org.xtext.example.sml.sml.PointD;
import org.xtext.example.sml.sml.ProbabilisticDecription;
import org.xtext.example.sml.sml.Rectangle;
import org.xtext.example.sml.sml.RectangleD;
import org.xtext.example.sml.sml.Region;
import org.xtext.example.sml.sml.Reward;
import org.xtext.example.sml.sml.Scope;
import org.xtext.example.sml.sml.SmlPackage;
import org.xtext.example.sml.sml.Swarmconf;
import org.xtext.example.sml.sml.Task;
import org.xtext.example.sml.sml.Time;
import org.xtext.example.sml.sml.Upperbound;
import org.xtext.example.sml.sml.UpperorEqualbound;

@SuppressWarnings("all")
public class SmlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SmlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SmlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SmlPackage.ARENA:
				sequence_Arena(context, (Arena) semanticObject); 
				return; 
			case SmlPackage.ATOMIC_INDICATOR:
				sequence_AtomicIndicator(context, (AtomicIndicator) semanticObject); 
				return; 
			case SmlPackage.BOOL_LITERAL:
				sequence_BoolLiteral(context, (BoolLiteral) semanticObject); 
				return; 
			case SmlPackage.CIRCLE:
				sequence_Position(context, (Circle) semanticObject); 
				return; 
			case SmlPackage.CIRCLE_D:
				sequence_CircleD(context, (CircleD) semanticObject); 
				return; 
			case SmlPackage.COMPOUND_INDICATOR:
				sequence_CompoundIndicator(context, (CompoundIndicator) semanticObject); 
				return; 
			case SmlPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case SmlPackage.CONSTANT_SIZE:
				sequence_ConstantSize(context, (ConstantSize) semanticObject); 
				return; 
			case SmlPackage.COORDINATE:
				sequence_Coordinate(context, (Coordinate) semanticObject); 
				return; 
			case SmlPackage.ELEMENT_DESCRIPTION:
				sequence_ElementDescription(context, (ElementDescription) semanticObject); 
				return; 
			case SmlPackage.ENVIRONMENT:
				sequence_Environment(context, (Environment) semanticObject); 
				return; 
			case SmlPackage.INDICATOR:
				sequence_Indicator(context, (Indicator) semanticObject); 
				return; 
			case SmlPackage.INTERVAL:
				sequence_Interval(context, (Interval) semanticObject); 
				return; 
			case SmlPackage.LIGHT:
				sequence_Light(context, (Light) semanticObject); 
				return; 
			case SmlPackage.LOWERBOUND:
				sequence_Lowerbound(context, (Lowerbound) semanticObject); 
				return; 
			case SmlPackage.LOWEROR_EQUALBOUND:
				sequence_LowerorEqualbound(context, (LowerorEqualbound) semanticObject); 
				return; 
			case SmlPackage.MISSION:
				sequence_Mission(context, (Mission) semanticObject); 
				return; 
			case SmlPackage.MISSION_OBJECTIVE:
				sequence_MissionObjective(context, (MissionObjective) semanticObject); 
				return; 
			case SmlPackage.MISSION_TIME:
				sequence_MissionTime(context, (MissionTime) semanticObject); 
				return; 
			case SmlPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SmlPackage.OBJECT:
				sequence_Object(context, (org.xtext.example.sml.sml.Object) semanticObject); 
				return; 
			case SmlPackage.OBSTACLE:
				sequence_Obstacle(context, (Obstacle) semanticObject); 
				return; 
			case SmlPackage.PENALTY:
				sequence_Penalty(context, (Penalty) semanticObject); 
				return; 
			case SmlPackage.POINT_D:
				sequence_Position(context, (PointD) semanticObject); 
				return; 
			case SmlPackage.PROBABILISTIC_DECRIPTION:
				sequence_ProbabilisticDecription(context, (ProbabilisticDecription) semanticObject); 
				return; 
			case SmlPackage.RECTANGLE:
				sequence_Position(context, (Rectangle) semanticObject); 
				return; 
			case SmlPackage.RECTANGLE_D:
				sequence_RectangleD(context, (RectangleD) semanticObject); 
				return; 
			case SmlPackage.REGION:
				sequence_Region(context, (Region) semanticObject); 
				return; 
			case SmlPackage.REWARD:
				sequence_Reward(context, (Reward) semanticObject); 
				return; 
			case SmlPackage.SCOPE:
				sequence_Scope(context, (Scope) semanticObject); 
				return; 
			case SmlPackage.SWARMCONF:
				sequence_Swarmconf(context, (Swarmconf) semanticObject); 
				return; 
			case SmlPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case SmlPackage.TIME:
				sequence_Time(context, (Time) semanticObject); 
				return; 
			case SmlPackage.UPPERBOUND:
				sequence_Upperbound(context, (Upperbound) semanticObject); 
				return; 
			case SmlPackage.UPPEROR_EQUALBOUND:
				sequence_UpperorEqualbound(context, (UpperorEqualbound) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Arena returns Arena
	 *
	 * Constraint:
	 *     s=Region
	 */
	protected void sequence_Arena(ISerializationContext context, Arena semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.ARENA__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.ARENA__S));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArenaAccess().getSRegionParserRuleCall_4_0(), semanticObject.getS());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AtomicIndicator returns AtomicIndicator
	 *
	 * Constraint:
	 *     oc=Occurence
	 */
	protected void sequence_AtomicIndicator(ISerializationContext context, AtomicIndicator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.ATOMIC_INDICATOR__OC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.ATOMIC_INDICATOR__OC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicIndicatorAccess().getOcOccurenceParserRuleCall_2_0(), semanticObject.getOc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns BoolLiteral
	 *     BoolLiteral returns BoolLiteral
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_BoolLiteral(ISerializationContext context, BoolLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Dimension returns CircleD
	 *     CircleD returns CircleD
	 *
	 * Constraint:
	 *     r=Double
	 */
	protected void sequence_CircleD(ISerializationContext context, CircleD semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.CIRCLE_D__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.CIRCLE_D__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCircleDAccess().getRDoubleParserRuleCall_1_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompoundIndicator returns CompoundIndicator
	 *
	 * Constraint:
	 *     oc=Occurence
	 */
	protected void sequence_CompoundIndicator(ISerializationContext context, CompoundIndicator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.COMPOUND_INDICATOR__OC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.COMPOUND_INDICATOR__OC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompoundIndicatorAccess().getOcOccurenceParserRuleCall_2_0(), semanticObject.getOc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (r=Region | (n=INT r=Region))
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Range returns ConstantSize
	 *     ConstantSize returns ConstantSize
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_ConstantSize(ISerializationContext context, ConstantSize semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.RANGE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.RANGE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantSizeAccess().getNINTTerminalRuleCall_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Coordinate returns Coordinate
	 *
	 * Constraint:
	 *     (x=Double y=Double)
	 */
	protected void sequence_Coordinate(ISerializationContext context, Coordinate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.COORDINATE__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.COORDINATE__X));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.COORDINATE__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.COORDINATE__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCoordinateAccess().getXDoubleParserRuleCall_0_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getCoordinateAccess().getYDoubleParserRuleCall_1_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentElements returns ElementDescription
	 *     ElementDescription returns ElementDescription
	 *
	 * Constraint:
	 *     (el='There' x=Range obj=Element r=ProbabilisticDecription)
	 */
	protected void sequence_ElementDescription(ISerializationContext context, ElementDescription semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.ELEMENT_DESCRIPTION__EL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.ELEMENT_DESCRIPTION__EL));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.ELEMENT_DESCRIPTION__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.ELEMENT_DESCRIPTION__X));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.ELEMENT_DESCRIPTION__OBJ) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.ELEMENT_DESCRIPTION__OBJ));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.ELEMENT_DESCRIPTION__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.ELEMENT_DESCRIPTION__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementDescriptionAccess().getElThereKeyword_0_0(), semanticObject.getEl());
		feeder.accept(grammarAccess.getElementDescriptionAccess().getXRangeParserRuleCall_2_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getElementDescriptionAccess().getObjElementParserRuleCall_3_0(), semanticObject.getObj());
		feeder.accept(grammarAccess.getElementDescriptionAccess().getRProbabilisticDecriptionParserRuleCall_4_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Environment returns Environment
	 *
	 * Constraint:
	 *     environment+=EnvironmentElements+
	 */
	protected void sequence_Environment(ISerializationContext context, Environment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Indicator returns Indicator
	 *
	 * Constraint:
	 *     (sp=Scope (oc=AtomicIndicator | oc=CompoundIndicator))
	 */
	protected void sequence_Indicator(ISerializationContext context, Indicator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Range returns Interval
	 *     Interval returns Interval
	 *
	 * Constraint:
	 *     (m=INT n=INT)
	 */
	protected void sequence_Interval(ISerializationContext context, Interval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.INTERVAL__M) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.INTERVAL__M));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.RANGE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.RANGE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntervalAccess().getMINTTerminalRuleCall_1_0(), semanticObject.getM());
		feeder.accept(grammarAccess.getIntervalAccess().getNINTTerminalRuleCall_3_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentElements returns Light
	 *     EnvironmentElement returns Light
	 *     Light returns Light
	 *
	 * Constraint:
	 *     (l='A' c=Color p=Position)
	 */
	protected void sequence_Light(ISerializationContext context, Light semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.LIGHT__L) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.LIGHT__L));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.LIGHT__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.LIGHT__C));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.LIGHT__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.LIGHT__P));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLightAccess().getLAKeyword_0_0(), semanticObject.getL());
		feeder.accept(grammarAccess.getLightAccess().getCColorParserRuleCall_5_0(), semanticObject.getC());
		feeder.accept(grammarAccess.getLightAccess().getPPositionParserRuleCall_11_0(), semanticObject.getP());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Range returns Lowerbound
	 *     Lowerbound returns Lowerbound
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_Lowerbound(ISerializationContext context, Lowerbound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.RANGE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.RANGE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLowerboundAccess().getNINTTerminalRuleCall_2_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Range returns LowerorEqualbound
	 *     LowerorEqualbound returns LowerorEqualbound
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_LowerorEqualbound(ISerializationContext context, LowerorEqualbound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.RANGE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.RANGE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLowerorEqualboundAccess().getNINTTerminalRuleCall_4_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MissionObjective returns MissionObjective
	 *
	 * Constraint:
	 *     in+=Indicator+
	 */
	protected void sequence_MissionObjective(ISerializationContext context, MissionObjective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MissionTime returns MissionTime
	 *
	 * Constraint:
	 *     T=Range
	 */
	protected void sequence_MissionTime(ISerializationContext context, MissionTime semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.MISSION_TIME__T) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.MISSION_TIME__T));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMissionTimeAccess().getTRangeParserRuleCall_7_0(), semanticObject.getT());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Mission returns Mission
	 *
	 * Constraint:
	 *     (t=Task m=Metric)
	 */
	protected void sequence_Mission(ISerializationContext context, Mission semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.MISSION__T) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.MISSION__T));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.MISSION__M) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.MISSION__M));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMissionAccess().getTTaskParserRuleCall_7_0(), semanticObject.getT());
		feeder.accept(grammarAccess.getMissionAccess().getMMetricParserRuleCall_8_0(), semanticObject.getM());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (arenas=Arena env=Environment sw=Swarmconf ob=MissionObjective)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.MODEL__ARENAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.MODEL__ARENAS));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.MODEL__ENV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.MODEL__ENV));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.MODEL__SW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.MODEL__SW));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.MODEL__OB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.MODEL__OB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getArenasArenaParserRuleCall_0_0(), semanticObject.getArenas());
		feeder.accept(grammarAccess.getModelAccess().getEnvEnvironmentParserRuleCall_1_0(), semanticObject.getEnv());
		feeder.accept(grammarAccess.getModelAccess().getSwSwarmconfParserRuleCall_2_0(), semanticObject.getSw());
		feeder.accept(grammarAccess.getModelAccess().getObMissionObjectiveParserRuleCall_3_0(), semanticObject.getOb());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentElements returns Object
	 *     EnvironmentElement returns Object
	 *     Object returns Object
	 *
	 * Constraint:
	 *     (obj='An' r=Region)
	 */
	protected void sequence_Object(ISerializationContext context, org.xtext.example.sml.sml.Object semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OBJECT__OBJ) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OBJECT__OBJ));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OBJECT__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OBJECT__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectAccess().getObjAnKeyword_0_0(), semanticObject.getObj());
		feeder.accept(grammarAccess.getObjectAccess().getRRegionParserRuleCall_4_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnvironmentElements returns Obstacle
	 *     EnvironmentElement returns Obstacle
	 *     Obstacle returns Obstacle
	 *
	 * Constraint:
	 *     (obs='An' r=Region)
	 */
	protected void sequence_Obstacle(ISerializationContext context, Obstacle semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OBSTACLE__OBS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OBSTACLE__OBS));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OBSTACLE__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OBSTACLE__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObstacleAccess().getObsAnKeyword_0_0(), semanticObject.getObs());
		feeder.accept(grammarAccess.getObstacleAccess().getRRegionParserRuleCall_4_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Occurence returns Penalty
	 *     Penalty returns Penalty
	 *
	 * Constraint:
	 *     (k=Double c=Condition)
	 */
	protected void sequence_Penalty(ISerializationContext context, Penalty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OCCURENCE__K) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OCCURENCE__K));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OCCURENCE__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OCCURENCE__C));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPenaltyAccess().getKDoubleParserRuleCall_3_0(), semanticObject.getK());
		feeder.accept(grammarAccess.getPenaltyAccess().getCConditionParserRuleCall_4_0(), semanticObject.getC());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Position returns Circle
	 *
	 * Constraint:
	 *     point=Coordinate
	 */
	protected void sequence_Position(ISerializationContext context, Circle semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.POSITION__POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.POSITION__POINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPositionAccess().getPointCoordinateParserRuleCall_0_2_0(), semanticObject.getPoint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Position returns PointD
	 *
	 * Constraint:
	 *     point=Coordinate
	 */
	protected void sequence_Position(ISerializationContext context, PointD semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.POSITION__POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.POSITION__POINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPositionAccess().getPointCoordinateParserRuleCall_2_2_0(), semanticObject.getPoint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Position returns Rectangle
	 *
	 * Constraint:
	 *     point=Coordinate
	 */
	protected void sequence_Position(ISerializationContext context, Rectangle semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.POSITION__POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.POSITION__POINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPositionAccess().getPointCoordinateParserRuleCall_1_2_0(), semanticObject.getPoint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProbabilisticDecription returns ProbabilisticDecription
	 *
	 * Constraint:
	 *     (dis=Distribution k=Region)
	 */
	protected void sequence_ProbabilisticDecription(ISerializationContext context, ProbabilisticDecription semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.PROBABILISTIC_DECRIPTION__DIS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.PROBABILISTIC_DECRIPTION__DIS));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.PROBABILISTIC_DECRIPTION__K) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.PROBABILISTIC_DECRIPTION__K));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProbabilisticDecriptionAccess().getDisDistributionParserRuleCall_3_0(), semanticObject.getDis());
		feeder.accept(grammarAccess.getProbabilisticDecriptionAccess().getKRegionParserRuleCall_7_0(), semanticObject.getK());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Dimension returns RectangleD
	 *     RectangleD returns RectangleD
	 *
	 * Constraint:
	 *     (l=Double w=Double h=Double)
	 */
	protected void sequence_RectangleD(ISerializationContext context, RectangleD semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.RECTANGLE_D__L) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.RECTANGLE_D__L));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.RECTANGLE_D__W) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.RECTANGLE_D__W));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.RECTANGLE_D__H) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.RECTANGLE_D__H));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRectangleDAccess().getLDoubleParserRuleCall_1_0(), semanticObject.getL());
		feeder.accept(grammarAccess.getRectangleDAccess().getWDoubleParserRuleCall_3_0(), semanticObject.getW());
		feeder.accept(grammarAccess.getRectangleDAccess().getHDoubleParserRuleCall_6_0(), semanticObject.getH());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Region returns Region
	 *
	 * Constraint:
	 *     (colors=Color? shape=Shape? name=ID referencepoint=Position? dimensions=Dimension?)
	 */
	protected void sequence_Region(ISerializationContext context, Region semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Occurence returns Reward
	 *     Reward returns Reward
	 *
	 * Constraint:
	 *     (k=Double c=Condition)
	 */
	protected void sequence_Reward(ISerializationContext context, Reward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OCCURENCE__K) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OCCURENCE__K));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.OCCURENCE__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.OCCURENCE__C));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRewardAccess().getKDoubleParserRuleCall_3_0(), semanticObject.getK());
		feeder.accept(grammarAccess.getRewardAccess().getCConditionParserRuleCall_4_0(), semanticObject.getC());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Scope
	 *
	 * Constraint:
	 *     (sp='At any point of time' | sp='At the end of the mission')
	 */
	protected void sequence_Scope(ISerializationContext context, Scope semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Swarmconf returns Swarmconf
	 *
	 * Constraint:
	 *     (x=Range r=Robot pr=ProbabilisticDecription)
	 */
	protected void sequence_Swarmconf(ISerializationContext context, Swarmconf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.SWARMCONF__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.SWARMCONF__X));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.SWARMCONF__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.SWARMCONF__R));
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.SWARMCONF__PR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.SWARMCONF__PR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwarmconfAccess().getXRangeParserRuleCall_5_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getSwarmconfAccess().getRRobotParserRuleCall_6_0(), semanticObject.getR());
		feeder.accept(grammarAccess.getSwarmconfAccess().getPrProbabilisticDecriptionParserRuleCall_7_0(), semanticObject.getPr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Task returns Task
	 *
	 * Constraint:
	 *     r=Region
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.TASK__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.TASK__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTaskAccess().getRRegionParserRuleCall_2_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Time returns Time
	 *
	 * Constraint:
	 *     x=Literal
	 */
	protected void sequence_Time(ISerializationContext context, Time semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.TIME__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.TIME__X));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeAccess().getXLiteralParserRuleCall_0_0(), semanticObject.getX());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Range returns Upperbound
	 *     Upperbound returns Upperbound
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_Upperbound(ISerializationContext context, Upperbound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.RANGE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.RANGE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpperboundAccess().getNINTTerminalRuleCall_2_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Range returns UpperorEqualbound
	 *     UpperorEqualbound returns UpperorEqualbound
	 *
	 * Constraint:
	 *     n=INT
	 */
	protected void sequence_UpperorEqualbound(ISerializationContext context, UpperorEqualbound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmlPackage.Literals.RANGE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmlPackage.Literals.RANGE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpperorEqualboundAccess().getNINTTerminalRuleCall_4_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
}
